# 스마트 컨트랙트 메모리

## Antelope 컨트랙트 데이터 저장소

보통 스마트 컨트랙트 데이터 저장소를 "테이블"이라고 이야기하지만 실제로는 이진 트리입니다. 룩업 키는 정렬된 셋(set)에 저장되며 어떤 요소를 찾아야 하는 상황이 되면 이진 검색을 수행합니다.&#x20;

이는 또한 어떠한 범위 내의 키를 효율적으로 셀 수 없다는 것을 의미합니다. 그래서 키를 세어보려면 모든 키를 순회 해야 합니다.&#x20;

데이터 모델을 더 잘 이해하려면 Antelope CDT 의 일부인 `multi_index.hpp` 안을 살펴보면 도움이 될 수 있습니다. 패키지에서 CDT 를 설치한 경우 `/usr/opt/eosio.cdt/1.8.1/include/eosolib/contracts/eosio/`에서 찾아볼 수 있습니다. 일반적으로 코드의 동작 방식을 이해하려면 CDT 와 함께 제공되는 헤더 파일을 살펴보는 것이 좋습니다.&#x20;

스마트 컨트랙트 데이터 상호 작용의 가장 중요한 부분은 네임스페이스 `internal_use_do_not_use` 라는 재미있는 이름을 가진 장소에 정의되어 있습니다. 이 네임스페이스 내부에는 여러 내장함수와 `nodeos` 가 WASM 가상 머신으로 내보낸 함수들이 있습니다.&#x20;

안타깝게도 헤더에는 이러한 하위 수준의 함수까지 설명되어 있지는 않으므로 `nodeos` 소스의`libraries/chain/include/eosio/chain/webassembly/interface.hpp`에서 해당 기능을 살펴봐야 합니다. 사실 이러한 함수가 정의하는 것은 `nodeos` 에 의해 관리되는 컨트랙트 데이터에 대한 저수준 접근 방식입니다.

이 함수는 컨트랙트 테이블에 행을 만들 때 어떤 일이 일어나고 있는지 잘 보여줍니다.

```
 int32_t db_store_i64(uint64_t scope, uint64_t table, 
                      uint64_t payer, uint64_t id, 
                      legacy_span<const char> buffer);
```

보시다시피 테이블의 행에 들어가는 값은 바이트를 추상화 한 벡터 값입니다. 그래서 노드는 테이블 안에 저장된 구조에 대해 아무것도 알지 못합니다. 행은 코드, 스코프(scope), 테이블 이름 및 Primary Key 값을 조합하여 고유성을 가지게 됩니다.(`db_store_i64` 는 code (코드를 실행하기 위한 컨트랙트 계정)을 가지고 있지 않습니다. 왜냐하면 컨트랙트에게 허용된 것은 테이블을 업데이트 하기 위한 액션 뿐이기 때문입니다. 그러나 db\_find\_i64 및 db\_lowerbound\_i64 에서는 전체 quardruple 을 볼 수 있습니다.  함수는 행의 내용을 검색할 수 있는 32비트 반복자(iterator)를 반환합니다.(db\_get\_i64 참조).&#x20;

`interface.hpp` 에서 `db_idx64_stor` 와 같이 보조 인덱스에 접근하는 함수를 찾을 수 있습니다(예: `db_idx64_store`). 여기서 다음과 같이 두 가지 중요한 사항을 알 수 있습니다.&#x20;

* 보조 인덱스는 테이블 행과 별도로 업데이트 됩니다. 그러나 CDT의 C++ `multi-index` 클래스는 행이 업데이트될 때마다 보조 인덱스를 업데이트해 주는 래퍼를 제공하고 있기 때문에 개발자는 이 사실을 알 수 없습니다.&#x20;
* 인수 목록을 보면 보조 인덱스를 관리하는 각 함수는 각 유형의 인덱스를 하나만 참조할 수 있는 것을 볼 수 있습니다. 그러나 우리는 동일한 유형의 인덱스를 여러 개 생성할 수 있다는 것을 이미 알고 있습니다. `multi_index` 클래스는 테이블 이름의 상위 4비트를 사용하여 주어진 테이블에 대해 동일한 유형의 여러 인덱스를 만듭니다. 그렇기 때문에 테이블 이름은 절대 13개의 기호로 구성될 수 없으며 12개의 기호가 최대값입니다.

`multi_index.hpp` 의 더 아래쪽으로 내려가면 `multi_index` 클래스 정의를 볼 수 있습니다. `multi_index` 클래스 정의는 이러한 저수준 호출을 위한 편리한 프로그래밍 인터페이스를 제공합니다.&#x20;

이 헤더 파일을 살펴보면 다음과 같은 몇 가지 흥미로운 사실을 알 수 있습니다.&#x20;

1. 테이블 행은 클래스 메서드 또는 반복자를 통해 액세스할 때마다 항상 저장소에서 검색되고 역직렬화 됩니다.&#x20;
2. 하지만 캐시가 있기 때문에 항상 그렇지는 않습니다. 다중 인덱스 객체는 검색된 행을 기억하고 다음 읽기에 반환합니다. 이렇게 하면 동일한 행에 여러 번 액세스할 경우 작업 속도가 빨라집니다. 그러나 다중 인덱스의 두 인덱스가 동일한 테이블을 참조하는 경우 행을 수정하거나 삭제하면 예기치 않은 효과가 발생할 수 있습니다. 경험상 동일한 액션을 실행할 때 동일한 테이블에 대해 다중 인덱스 개체를 여러 개 만들지 않도록 하는 것이 좋습니다.&#x20;
3. 행을 지울 때마다 반복자의 다음 행이 컨트랙트 저장소에서 검색됩니다. 따라서 행 지우기는 값싼 작업이 아닙니다. 액션에서 한 행을 삭제하더라도 액션이 실행될 때 적어도 두 개 이상의 행을 검색되기 때문입니다.

아래는 더 생각 해 볼 만한 주제입니다.

* 컨트랙트 테이블의 데이터는 표준 방식으로 직렬화 될 필요가 없습니다. 노드는 바이트 벡터의 내부를 신경 쓰지 않습니다. 물론 HTTP API 와 히스토리 인덱스는 중요하기 때문에 개발자는 데이터를 저장하는 다른 방법을 선택할 수 있습니다.&#x20;
* 보조 인덱스는 이론적으로 가능하지만 표준 다중 인덱스가 모든 행에 대해 자동으로 보조 인덱스 항목을 만들기 때문에 다른 클래스가 필요합니다. 예를 들어 테이블에는 boolean 플래그가 있으며 이 플래그가 true 인 행에만 액세스할 수 있게 만드는 식 입니다. 이론적으로 보조 인덱스가 이 플래그가 설정된 행만 취급하는 경우라면 RAM을 크게 절약할 수 있습니다. 유일한 문제는 이 방법을 실행할 수 있는 실전 테스트를 거친 라이브러리가 없다는 것입니다.

## RAM 지불자와 할당&#x20;

저수준 작업(Low-level Operation)에서 새로운 메모리 할당이 필요할 경우 `payer` 매개 변수를 사용합니다. 노드는 모든 테이블 행의 소유권을 추적하고 payer 의 할당량에서 필요한 메모리 크기만큼 차감합니다.&#x20;

`Nodeos` 는 컨트랙트 자체 또는 트랜잭션을 RAM Payer 로 승인한 계정만 허용합니다.&#x20;

각 계정은 데이터 구조에 사용할 수 있는 RAM 할당량을 가지고 있습니다. 또한 `eosio` 시스템 컨트랙트와 같은 권한 있는 계정에는 무제한으로 RAM 이 부여됩니다.&#x20;

계정에 할당량을 부여하는 방법은 어떻게 시스템 컨트렉트를 구현해 놓았는가에 달려 있습니다. 대부분의 블록체인에서 RAM은 RAM 마켓에서 구입해야 합니다.
