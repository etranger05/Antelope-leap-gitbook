---
description: Performance and scaling
---

# 스마트 컨트랙트의 퍼포먼스와 스케일링

## check() 의 오버헤드에 주의

`check()`는 CDT에 정의되어 있는 함수이며, 인자로 Boolean 값과 문자열을 받습니다. Boolean 이 거짓이면 전체 트랜잭션이 중단되고 같이 전달 받은 문자열을 오류 메시지로 출력합니다.&#x20;

`check()` 를 사용할 때는 다음과 같이 문자열을 연결하고 동적 값을 삽입하는 것이 좋습니다.

```
check(accounts_itr != _accounts.end(), 
      "Account " + account_name.to_string() + " is unknown");
```

그러나 CDT의 `check.hpp` 는 `check()` 를 두 개 또는 세 개의 인수를 가진 인라인 함수로 정의하므로 조건을 검사하기 전에 매번 문자열을 작성하게 됩니다. 따라서 위의 예제와 이름-문자열 변환은 `check()` 가 호출될 때마다 수행됩니다. `check()` 를 많이 사용하거나 루프에서 무언가를 확인하는 경우 불필요한 문자열 변환 오버헤드가 필연적으로 발생하게 됩니다.&#x20;

따라서 다음과 같이 리팩터링 하면 조건이 참으로 평가되는 시간에 대한 CPU 작업이 줄어듭니다. 실패 시 오류 메시지를 구성하는 데 필요한 CPU 시간은 특별히 신경 쓸 필요는 없습니다.

```
if( accounts_itr == _accounts.end() ) {
  check(false, "Account " + account_name.to_string() + " is unknown");
}
```

## 테이블 행에 접근하기

[데이터 설계](../basic-antelope-leap/data-design.md) 단원에서 설명한 대로 테이블 행에 접근할 때마다 두 가지 작업이 수행됩니다.&#x20;

첫째, `nodeos` 는 내부의 다중 인덱스 구조에서 행을 찾습니다. 이는 (상태 메모리의 모든 테이블 행 수에 대한 로그 복잡도를 갖습니다. 보조 인덱스를 사용하는 경우 인덱스에서 항목을 찾은 다음 Primary Key 로 행을 찾는 식으로 두 번 작업이 수행됩니다.&#x20;

그 다음 행 내용이 연속된 바이트 데이터에서 VM 메모리의 구조체로 역직렬화 됩니다. 이는 행 크기에 대한 선형 복잡도를 가집니다.&#x20;

따라서 행이 길거나 행을 더 자주 검색해야 하는 딜레마가 있는 경우 가장 좋은 방법은 실행 중인 블록 체인 위에서 테스트하고 평가 해 보는 것입니다. 전체 블록체인 상태가 성장함에 따라 글로벌 메모리에서 행을 찾는 시간 또한 증가하고 있으므로, 가장 좋은 방법은 프로덕션 블록체인에서 테스트를 몇 가지 해 보는 것입니다.
