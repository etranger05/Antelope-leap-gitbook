---
description: "Performance \bOptimization"
---

# 스마트 컨트랙트 성능 최적화

## check() 의 오버헤드에 주의

`check()`는 CDT에 정의되어 있는 함수이며, 인자로 `Boolean` 값과 문자열을 받습니다. `Boolean` 이 거짓이면 전체 트랜잭션이 중단되고 같이 전달 받은 문자열을 오류 메시지로 출력합니다.

`check()` 를 사용할 때는 다음과 같이 문자열을 연결하고 동적 값을 삽입하는 것이 좋습니다.

```
check(accounts_itr != _accounts.end(), 
      "Account " + account_name.to_string() + " is unknown");
```

그러나 CDT의 `check.hpp` 는 `check()` 를 두 개 또는 세 개의 인수를 가진 인라인 함수로 정의하므로 조건을 검사하기 전에 매번 문자열을 작성하게 됩니다. 따라서 위의 예제와 이름-문자열 변환은 `check()` 가 호출될 때마다 수행됩니다. `check()` 를 많이 사용하거나 루프에서 무언가를 확인하는 경우 불필요한 문자열 변환 오버헤드가 필연적으로 발생하게 됩니다.

따라서 다음과 같이 리팩터링 하면 조건이 참으로 평가되는 시간에 대한 CPU 작업이 줄어듭니다. 실패 시 오류 메시지를 구성하는 데 필요한 CPU 시간은 특별히 신경 쓸 필요는 없습니다.

```
if( accounts_itr == _accounts.end() ) {
  check(false, "Account " + account_name.to_string() + " is unknown");
}
```

## 테이블 행에 접근하기

[데이터 설계](../basic-antelope-leap/data-design.md) 단원에서 설명한 대로 테이블 행에 접근할 때마다 두 가지 작업이 수행됩니다.

첫째, `nodeos` 는 내부의 다중 인덱스 구조에서 행을 찾습니다. 이는 (상태 메모리의 모든 테이블 행 수에 대한 로그 복잡도를 갖습니다. 보조 인덱스를 사용하는 경우 인덱스에서 항목을 찾은 다음 Primary Key 로 행을 찾는 식으로 두 번 작업이 수행됩니다.

그 다음 행 내용이 연속된 바이트 데이터에서 VM 메모리의 구조체로 역직렬화 됩니다. 이는 행 크기에 대한 선형 복잡도를 가집니다.

따라서 행이 길거나 행을 더 자주 검색해야 하는 딜레마가 있는 경우 가장 좋은 방법은 실행 중인 블록 체인 위에서 테스트하고 평가 해 보는 것입니다. 전체 블록체인 상태가 성장함에 따라 글로벌 메모리에서 행을 찾는 시간 또한 증가하고 있으므로, 가장 좋은 방법은 프로덕션 블록체인에서 테스트를 몇 가지 해 보는 것입니다.

## 10의 승수 (Power of Ten)

예를 들어 자산(asset) 정밀도에 따라 원시 정수 자산 값(raw integer asset value)을 부동 소수점 숫자로 변환하는 경우와 같이, 컨트랙트 내부에서 10의 거듭제곱을 계산해야 하는 경우, 개발자들은 표준 C++ pow() 함수를 많이들 사용합니다. 이 함수는 잘 동작하지만 사실 CPU 비용이 높습니다.

더 효율적인 방법이 있는데, 필요한 숫자의 10의 거듭제곱을 미리 계산하여 배열에 저장해 두고 단순히 필요할 때 원하는 숫자를 가져오는 것입니다. 실제로 CDT가 제공하는 `powers.hpp` 는 정확히 이와 같이 동작합니다.

## 외부 Worker 에게 작업을 위임.&#x20;

컨트랙트는 때때로 CPU 사용률이 높은 계산이나 데이터를 조작하는 작업을 해야 할 때가 있습니다. 이러한 작업이 최종 사용자의 트랜잭션과 함께 로드되면 사용자 경험에 별로 좋지 않은 영향을 줄 수 있습니다. 사용자가 보다 더 높은 CPU 사용량을 가질 수 있어야 하기 때문에 충분치 않은 CPU 리소스로 인하여 오류가 더 자주 발생할 것입니다.

이에 대처할 수 있는 한 가지 방법은, 작업을 나중에 처리할 수 있도록 대기열에 저장하고 다른 사용자가 작업을 트리거하도록 하는 것입니다. 그러면 백엔드 오라클 스크립트가 필요한 만큼 프로세스를 트리거 합니다.&#x20;

각각의 `worker` 에 대해 실행된 작업의 수를 카운터로 유지하고 그에 따라 작업에 대한 보상을 정의하는 방법도 생각해 볼 수도 있습니다. 보상이 충분히 높은 경우 서드파티 사용자가 백엔드 스크립트를 설정하고 프로세싱 작업을 동시에 트리거 하도록 동기부여 할 수도 있습니다. 이러한 접근 방식은 어쩌면 "채굴" 경제로도 이어질 수도 있을 것입니다.&#x20;

처리할 것이 없는 트랜잭션은 스마트 컨트랙트가 거부할 수 있어야 합니다. 그렇지 않으면 블록체인 이력(history)이 쓸모없는 트랜잭션으로 오염되어 유지보수 비용이 증가하고 사용자 경험이 저하될 수 있습니다.
