---
description: Transaction Lifecycle
---

# 트랜잭션 생애주기

## 시작하기 전에

간결하고 핵심에 집중한 설명을 위해 Leap 헤더 파일에 정의된 일부 필드에 대한 설명(예: 컨텍스트 없는 액션)은 생략하였습니다. 이 단원은 트랜잭션이 어떻게 동작하는것인지 설명하는 것이 목적이지, 정확히 무엇으로 구성되는지 설명하는 레퍼런스 문서가 아닙니다.&#x20;

또한 `name` 은 기본적으로 64비트 부호 없는 정수의 텍스트 표현인 Leap 데이터 유형 `eosio::name` 을 의미합니다. `name` 은 Leap 의 많은 곳에서 계정, 작업, 테이블 및 권한을 지정하기 위해 사용됩니다.

## 트랜잭션 구성하기

블록체인에서 트랜잭션은 두 가지 형태로 표현됩니다. 즉, 트랜잭션이 HTTP RPC로 푸시되거나 스마트 컨트랙트(지연 트랜잭션을 생성하는 것. 이러한 트랜잭션은 더 이상 사용되지 않으며 해당 트랜잭션에 대한 지원은 중단될 것입니다.)에 의해 생성됩니다.&#x20;

`/v1/chain/send_transaction` RPC 호출은 트랜잭션 헤더, 작업 및 서명으로 구성된, 직렬화된 `chain::packed_transaction` 오브젝트를 사용합니다. EOSIO 소스 코드의 라이브러리 `/chain/include/eosio/chain/transaction.hpp` 헤더 파일에서 이러한 오브젝트의 세부 정보를 찾아볼 수 있습니다.&#x20;

트랜잭션 헤더에는 클라이언트가 트랜잭션을 보내기 전에 검색해야 하는 몇 가지 값이 포함되어 있습니다. 현재 eosjs 라이브러리는 값을 캐시하여 재사용하지 않고 모든 트랜잭션을 보내기 전에 일일히 필요한 값을 요청하고 있습니다. 다른 클라이언트 라이브러리는 RPC 상호 작용을 최적화하고 재사용할 수 있는 값은 재사용하고 있습니다. 다음은 트랜잭션 헤더의 몇 가지 중요한 필드입니다.&#x20;

* `time_point_sec expiration` - 트랜잭션이 블록안에 배치되지 않을 경우 트랜잭션이 만료되는 절대 시간값입니다. 트랜잭션이 만료되면 노드에서 트랜잭션을 삭제하고 전파를 중지합니다.&#x20;
* `uint16_t ref_block_num` - 이 필드는 32비트 블록 번호의 가장 낮은 16비트로 구성됩니다. 즉, 대략 9시간 이상 경과된 블록 번호를 참조하는 경우 트랜잭션을 블록에 배치할 수 없습니다.&#x20;
* `uint32_t ref_block_prefix` -- 이 필드에는 참조 블록 ID의 가장 낮은 32비트(블록 ID는 블록 컨텐츠의 sha256 해시값입니다)가 포함됩니다.

따라서 유효한 트랜잭션을 보내려면 클라이언트가 유효한 블록 번호와 ID를 가져와야 합니다. 가장 신뢰할 수 있는 방법은 마지막 "비가역성 블록(되돌릴 수 없는 블록)"(이 정보는 get\_info RPC 호출을 통해 검색됨)을 취하는 것이며 만료 시간은 미래여야 한다는 점을 주의해야 합니다. 그러나 작업 순서가 중요한 일부 애플리케이션의 경우 컨트랙트가 작업 순서를 보장하지 않기 때문에 헤드 블록을 대신에 의존 할 수 있습니다.&#x20;

액션은 트랜잭션의 핵심을 구성합니다. 액션은 해당 트랜잭션이 정확히 무엇을 해야 하는지 정의합니다. 트랜잭션에는 여러 가지 액션이 있을 수 있으며 전체 트랜잭션은 해당 트랜잭션의 모든 액션이 성공한 경우에만 성공으로 간주합니다. 또한 트랜잭션의 첫 번째 액션에 대한 첫 번째 권한자에게 CPU 및 NET 리소스가 청구됩니다.&#x20;

헤더 파일 라이브러리 `/chain/include/eosio/chain/action.hpp` 는 액션 개체와 속성을 정의합니다. 액션에서 가장 중요한 필드는 다음과 같습니다.

* name account - WASM 스마트 컨트랙트를 포함하는 계정입니다. 각 액션은 단순히 관련된 WASM 블록을 호출하는 것입니다.&#x20;
* name name - 다소 혼란스러운 액션 이름이며, 이름 유형입니다. 일반적으로 WASM 코드에는 액션 이름에 따라 다른 함수를 호출하는 디스패처가 있습니다.&#x20;
* vector\<permission\_level> authorisation - 이 실행을 인증하는 계정 및 권한을 정의합니다. 트랜잭션에는 인증 요구 사항을 충분히 충족할 수 있는 서명이 포함되어야 합니다.&#x20;
* bytes data - 액션 인수의 바이트 벡터입니다. 일반적으로 이것은 컨트랙트 계정에 의해 선언된 ABI에 해당하는 직렬화된 구조입니다. 하지만 nodeos 는 보내는 순간에 무엇이 들어 있는지 신경 쓰지 않습니다. 데이터 내용을 역직렬화하고 해석하는 것은 전적으로 WASM 코드가 하는 일입니다.

따라서 트랜잭션을 보내기 전에 액션 호출 방법과 인수를 직렬화하는 방법을 알아야 합니다. 이 정보는 컨트랙트 계정에 의해 WASM 코드와 함께 ABI에 게시됩니다.

&#x20;WASM을 사용하고 ABI를 사용하지 않은 계정이 있을 수 있으며(이 경우 인수의 의미를 이해하려면 WASM을 분석해야 합니다), ABI는 사용하지만 WASM을 사용하지 않은 계정도 있을 수 있습니다(이 경우 무엇을 보내든 수락됩니다.)

eosjs 와 같은 일반적인 클라이언트는 transact 메서드에서 컨트랙트 이름, 액션 이름 및 인수의 맵을 얻습니다. 이 경우 지정된 컨트랙트 계정의 ABI를 검색하고 ABI 사양에 따라 액션 인수를 패킹해야 합니다. 이 외에도 참조 블록 정보도 검색합니다. 보시다시피 단 하나의 트랜잭션을 준비하는데에도 많은 일들이 일어나고 있습니다.&#x20;

또한 트랜잭션에는 각 액에 지정된 자동화에 해당하는 타원 곡선 서명(elliptic curve signatures)이 있어야 합니다. 클라이언트는 일반적으로 어떤 키가 필요한지 미리 알지 못하기 때문에 어떤 키가 트랜잭션에 서명해야 하는지 확인하기 위해 다른 RPC 요청을 다시 보냅니다.

각 액션은 동일한 트랜잭션에 속하는 액션을 추가로 생성할 수 있습니다. 이러한 액션에는 `require_recipient()` 을 호출하여 만들어낸 알림과 `eosio::action::send()` 메서드로 생성된 새 액션의 두 가지 타입이 있습니다. 현재 실행 중인 액션 내에서 이러한 호출을 할 때마다 스마트 컨트랙트가 바로 실행되는 것은 아닙니다. 대신 알림은 액션 실행 대기열의 다른 위치에 삽입됩니다. 알림은 대기열의 맨 앞에 배치되므로 현재 액션이 완료된 후 먼저 실행되고 `send()`에 의해 생성된 새 액션이 대기열의 끝으로 푸시됩니다.&#x20;

`Nodeos` 는 실행 대기열에서 액션을 하나씩 선택하고 각 액션에 대해 새 WASM 가상 시스템을 생성합니다. 가상 시스템은 실행 속도를 높이기 위해 다양한 캐싱 및 최적화 기술을 사용하고 있습니다. 그러나 일반적으로 각 실행은 빈 가상 환경에서 시작되며 한 번에 하나의 액션만 실행됩니다.

## 트랜잭션 브로드캐스팅

트랜잭션이 `/v1/chain/send_transaction` RPC 호출 또는 p2p 인터페이스를 통해 노드에 도착하면 해당 트랜잭션이 처리됩니다. 노드가 새로운 WASM 가상 시스템을 생성하고 현재 블록체인 상태에 대해 트랜잭션을 실행합니다. 모든 검사가 성공하고 트랜잭션 성공적으로 완료되면 노드 구성의 읽기 모드 매개 변수에 따라 상태 변경 내용이 삭제되거나 일시적으로 보존됩니다.

노드는 트랜잭션이 성공하면 인접한 p2p 네트워크로 브로드캐스트하고 트랜잭션이 실패하면 폐기합니다.&#x20;

트랜잭션이 RPC를 통해 노드에 도착한 후 곧바로 처리되는데 이 때 오류가 발생하면 오류 세부 정보가 RPC 응답으로 클라이언트에 다시 보고됩니다.&#x20;

트랜잭션이 p2p 인터페이스를 통해 도착하여 처리가 중에 실패하면 해당 트랜잭션은 조용히 삭제되고 보낸 사람은 즉각적인 피드백을 받지 못합니다.&#x20;

노드는 이러한 추측성(_speculative_) 트랜잭션을 전체 p2p 네트워크에 전파하고, 결국 활성화된 블록 생성자 노드에 나타납니다. 이러한 트랜잭션은 지금까지 블록체인 상태 및 트랜잭션 속성이 트랜잭션을 블록에 배치할 수 있다는 낙관적인 가정을 바탕으로 처리되었기 때문에 추측성 트랜잭션이라고 합니다.

## 블록 서명

블록 생성 스케줄에 포함된 각 BP는 자기 차례가 되면 6초 동안 12개의 블록을 서명합니다. 새 블록 서명이 시작되기 전에 발생한 추측성 트랜잭션은 저장하고 다시 처리한 후 새 블록에 배치합니다. 블록이 서명되는 동안 추측성 트랜잭션이 도착하면 블록에 배치될 수도 있습니다.&#x20;

BP 노드에는 블록이 충분히 큰 시기를 결정하는 여러 구성 매개 변수가 있으며 블록으로 더 많은 트랜잭션을 가져오는 것을 중지해야 합니다. 완료되면 BP 노드는 설정된 블록 서명 키를 사용하여 블록 컨텐츠의 sha256 해시를 가져온 뒤 ECC 서명을 추가합니다.&#x20;

블록 서명 키가 꼭 Antelope 계정과 연결되어 있을 필요는 없으며, 일반적으로 보안적 관점에서 봤을 때 블록 서명 및 계정 권한에 동일한 키를 사용하지 않는 것이 좋습니다.&#x20;

액티브  BP 가 블록에 서명하면 근처의 모든 p2p 네트워크로 전송하고, 다시 더 넓은 p2p 네트워크로 블록을 전파합니다.

## 포크와 최종성(Fork and Finality)

네트워크 최적화 및 블록체인 안정성에 있어 중요한 요소 중 하나는, 새로운 블록을 만들기 시작하기 전에 현 BP 의 마지막 블록이 다음 BP 에게 일정내에 도착해야 한다는 것입니다.&#x20;

이전 BP 의 마지막 블록이 현재 BP 에게 도착하지 않은 경우 새 블록을 생성할 시간이 되면 마이크로포크(Microfork) 상황이 발생합니다. 즉, 동일한 번호를 가진 두 버전의 블록이 p2p 네트워크를 통해 전파됩니다. 동일한 블록의 이전 버전을 이미 수신하고 처리한 노드는 상태를 롤백하고 새 블록을 가져와야 합니다. 이로 인해 블록체인 클라이언트는 다음 순간에 사라질 수 있는 트랜잭션을 보거나 여전히 존재할 수 있지만 블록 내 트랜잭션 순서는 다릅니다.&#x20;

마이크로포크의 원인이 될 수 있는 몇 가지 장애 시나리오가 있습니다. 예를 들어, BP 노드의 서버 클럭이 시간을 제대로 동기화하고 있지 못한 경우 입니다. 최악의 시나리오는 현역 BP 의 3분의 1이 오프라인 상태가 되어 LIB가 전진하지 못하는 경우입니다. 이러한 상황이 발생하면 LIB 이후의 모든 블록이 폐기될 수 있습니다.&#x20;

블록은 다수의 액티브 BP 가 블록에 두 번 서명하는 즉시 최종 블록이 됩니다. 즉, 각각 6초씩의 4/3+2 생성 구간에서 최종 블록이 결정되기 전에 통과해야 하며 이후 마이크로포크로 인해 다시 쓰여질 수 없습니다. 따라서 약 2분 정도의 비가역 지연이 발생합니다.&#x20;

현재 최종 시간을 1-2블록으로 줄여 블록체인의 안정성과 사용성을 크게 높이는 것을 목표로 작업이 진행 중입니다.
