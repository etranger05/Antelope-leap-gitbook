# 트랜잭션 프로토콜(작업중)

## 개요

액션은 스마트 컨트랙트 내부에서 실행되는 일련의 동작/행동의 원자적 (실행되면 중단할 수 없음. 완전히 전부 실행되거나 그렇지 못하면 아예 실행을 하지 않음) 단위 입니다. 더 높은 시선에서 보면, 분산 응용프로그램 내에서 자동으로 실행되는 여러 액션이 모여 트랜잭션을 만들게 됩니다.&#x20;

데이터베이스 트랜잭션과 마찬가지로 블록체인 트랜잭션을 구성하는 액션 그룹은 미리 정의된 순서대로 하나씩 전부 성공해야 하며, 그렇지 않을 경우 트랜잭션은 실패하게 됩니다. 트랜잭션이 실패하면 트랜잭션 원자성 및 무결성을 유지하기 위하여 트랜잭션을 처리하기 이전 상태로 블록체인 상태가 복원됩니다. 이렇게 하여 실패한 시점 이전에 실행된 동작때문에 발생하는 부작용을 방지할 수 있습니다.

### 액션

미리 블록체인에 만들어져 있던 하나 혹은 그 이상의 행위자(actor)가 액션을 승인할 수 있습니다. 액션을 만들 때는 스마트 컨트랙트 내부에 명시적으로 만들거나 응용프로그램 코드로 암시적으로 만들 수 있습니다.&#x20;

주어진 `actor:action` 쌍에 대해 최대 한 개의 최소 권한이 명시적으로 부여됩니다. 명시적으로 최소 사용 권한이 설정되지 않은 경우 암시적인 기본값은 `actor@active` 입니다. 각 행위자는 주어진 액션에 대한 개인 최소 권한을 독립적으로 설정할 수 있습니다. 또한 Antelope 소프트웨어 내에 복잡하지만 유연한 인증 구조가 구축되어 있어 행위자가 다른 계정을 대신하여 액션을 수행할 수도 있습니다. 이 때는 행위자가 액션을 보낼 수 있도록 추가 검사가 이루어집니다.

트랜잭션에는 두 가지 타입의 액션이 있습니다. 각각의 타입은 Antelope 소프트웨어에서 실행되는 방법이 다릅니다.

1. 서명된 트랜잭션에서 볼 수 있는 명시적 액션(2 참조). 트랜잭션 인스턴스).&#x20;
2. 트랜잭션 처리의 부작용으로 생성되는 암시적(인라인) 액션.&#x20;

명시적 액션과 마찬가지로 암시적(인라인) 액션도 스마트 컨트랙트 코드에 정의됩니다. 주요 차이점은 인라인 액션은 네트워크를 통해 전파되는 실제 트랜잭션에 포함되지 않고 결국 블록에 포함된다는 것입니다. 그래서 암시적이라 합니다.

#### 명시적 액션

명시적 액션이라고도 불리는 일반(Regular) 액션은 이름에서 알 수 있듯이 트랜잭션을 구성하는 액션 목록에 포함됩니다. 명시적 액션은 트랜잭션에 삽입되기 전에 액션 인스턴스로 인코딩 됩니다(3.4.3 참조). 명시적 액션은 트랜잭션의 일부로서 실행될 액션과 그 액션에서 사용하는 페이로드 데이터를 포함합니다.&#x20;

#### 암시적 액션

암시적 성격을 가지는 인라인 액션은 트랜잭션 내에서 명시적 호출자(caller) 액션(또는 중첩된(nested) 경우 다른 인라인 액션)의 결과로 생성되며, 호출자 액션을 계속 수행하려면 해당 암시적 액션이 필요합니다. 따라서 인라인 액션은 호출자 액션의 동일한 범위 및 권한 내에서 작동합니다. 그렇기 때문에 인라인 액션은 동일한 트랜잭션 내에서 실행될 수 있습니다.

### 스마트 컨트랙트

Antelope 에서 스마트 컨트랙트는 보통 기능별로 그룹화된 일련의 액션과 이러한 액션이 의존하는 일련의 타입 정의로 구성됩니다. 그렇기 때문에 액션은 스마트 컨트랙트가 하는 행동이 무엇인지를 설명하는 것이라 볼 수 있습니다. 표준 Antelope 컨트랙트에는 계정 생성, BP 투표, 토큰 운영 과 같은 행동일을 하기 한해 몇 가지 액션이 구현되어 있습니다. 응용프로그램 개발자는 자신의 스마트 컨트랙트 및 응용프로그램 내에서 자신의 커스텀 액션을 만들어 이 기능을 확장하거나, 대체하거나 또는 사용하지 않도록 할 수 있습니다. 반면 트랜잭션은 일반적으로 응용 프로그램 수준에서 만들어집니다.&#x20;

#### 스마트 컨트랙트 구현

Antelope 스마트 컨트랙트는 `eosio::contract` 에서 파생된 C++ 클래스로 구현되며, 액션은 파생된 C++ 클래스 안의 C++ 메소드로 구현됩니다. 반면 트랜잭션은 Antelope 응용프로그램 내에서 동적 형태의 트랜잭션 인스턴스로 생성됩니다. Antelope 소프트웨어는 각 트랜잭션 인스턴스가 처리되고 생성, 서명, 유효성 검사 및 실행 단계를 거치는 동안 그 트랜잭션의 상태를 추적합니다.

## 트랜잭션 인스턴스

트랜잭션 인스턴스는 다음과 같은 요소들로 구성됩니다.

1. 트랜잭션 헤더
2. 트랜잭션을 구성하는 액션 인스턴스 목록
3. 트랜잭션 확장 목록.&#x20;

트랜잭션 헤더에는 트랜잭션 만료 시간을 기준 시점으로 블록에 트랜잭션이 포함되어 있는지를 확인하는 데 필요한 정보가 포함되어 있으며, 이 정보는 트랜잭션이 실행되도록 푸시될 때 계산됩니다. 다른 필드에는 트랜잭션을 포함하는 블록 번호, "크로스 체인" 또는 "크로스 포크" 공격을 방지하는 데 사용되는 블록 ID 접두사, CPU 및 네트워크 사용량의 상한선, 트랜잭션 지연 시간(해당하는 경우)이 포함됩니다.&#x20;

아래 다이어그램은 트랜잭션 인스턴스를 도식화하여 보여줍니다.

![](<../../.gitbook/assets/image (8).png>)

액션 인스턴스는 일반 액션 과 컨텍스트 없는 액션으로 구분할 수 있습니다. 서명은 트랜잭션 수준에서 생성되고 검증됩니다. 계정 및 권한은 액션별로 처리됩니다. 각 액션 인스턴스에는 액션에 지정된 액터의 권한 수준과 해당 액션에 대한 스마트 컨트랙트에 정의된 실제 권한에 따라 실행 권한이 부여되는지 여부를 검증하는 정보가 포함되어 있습니다[(3.4.2 참조). 권한 확인](https://developers.eos.io/welcome/latest/protocol-guides/transactions\_protocol/#342-permission-check)).

### 트랜잭션 ID

트랜잭션 인스턴스는 어떠한 트랜잭션을 다른 트랜잭션과 구별하게 해 주는 최소 필드 집합을 가지고 있습니다. 트랜잭션 ID 는 트랜잭션 인스턴스에 포함된 기본 필드들을를 암호화 해시 처리하여 만듭니다. 즉, 트랜잭션 ID는 트랜잭션 내에 캡슐화된 액션 목록, 트랜잭션 헤더 및 트랜잭션 확장(선택 사항)에 의해 결정됩니다.&#x20;

트랜잭션 인스턴스는 서명된 트랜잭션 인스턴스(Signed Transaction Instance) 또는 패킹된 트랜잭션 인스턴스(Packed Transaction Instance)로 더 세분화 할 수 있습니다.

### 서명된 트랜잭션 인스턴스(Signed Transaction Instance)

서명된 트랜잭션은 트랜잭션 스키마의 기본 내용을 확장하여 트랜잭션에 서명한 계정에 의해 생성된 서명을 포함합니다. 또한 트랜잭션 인스턴스에 컨텍스트 없는 액션이 들어 있다면 그와 관련된 데이터도 포함됩니다(아래 signed\_transaction 스키마 참조). 연관된 행위자(actor)가 서명을 해야 트랜잭션 실행 및 유효성 검사를 위한 준비를 할 수 있습니다.

#### signed\_transaction 스키마 <a href="#signed_transaction-schema" id="signed_transaction-schema"></a>

| Name                     | Type                | Description                                                                                                        |
| ------------------------ | ------------------- | ------------------------------------------------------------------------------------------------------------------ |
| `expiration`             | `time_point_sec`    | 트랜잭션 만료 시간                                                                                                         |
| `ref_block_num`          | `uint16_t`          | 마지막 2^16 블록에서 블록의 하위 16 bit.                                                                                       |
| `ref_block_prefix`       | `uint32_t`          | ref\_block\_num' 가 참조하는 블록ID의 하위 32 bit.                                                                           |
| `max_net_usage_words`    | `unsigned_int`      | 청구되는 네트워크 대역폭의 상한 (in 64-bit words)                                                                                |
| `max_cpu_usage_ms`       | `uint8_t`           | 청구되는 total CPU 타임의 상한(ms 단위)                                                                                       |
| `delay_sec`              | `unsigned_int`      | 트랜잭션 지연시간(초 단위)                                                                                                    |
| `context_free_actions`   | `action` 배열         | context-free 액션이 있다면 그 목록                                                                                          |
| `actions`                | `action` 배열         | [액션 인스턴스 배열](https://developers.eos.io/welcome/latest/protocol-guides/transactions\_protocol/#343-action-instance) |
| `transaction_extensions` | `extensions_type`   | 추가 기능을 지원하기 위한 확장 필드                                                                                               |
| `signatures`             | `signature_type` 배열 | 트랜잭션이 서명된 후 디지털 서명                                                                                                 |
| `context_free_data`      | `bytes` 배열          | context-free 액션 데이터가 있다면 그 목록                                                                                      |

### 패킹된 트랜잭션 인스턴스(Packed Transaction Instance)

패킹된 트랜잭션은 압축되어 서명된 트랜잭션이며, 압축 해제 및 신속한 검증을 위해 추가된 하우스키핑 필드(housekeeping field)를 가지고 있습니다. 패킹된 트랜잭션은 장기적으로 설치 공간과 블록 크기를 최소화 합니다(아래 packed\_transaction 스키마 참조). 패킹된 트랜잭션은 Antelope 블록체인에서 가장 일반적인 타입의 트랜잭션입니다. 따라서 트랜잭션이 블록으로 푸시되면 압축 여부에 관계없이 실제로는 패킹된 트랜잭션이 됩니다.

#### packed\_transaction 스키마 <a href="#packed_transaction-schema" id="packed_transaction-schema"></a>

| Name                       | Type                  | Description                            |
| -------------------------- | --------------------- | -------------------------------------- |
| `signatures`               | `signature_type`      | 트랜잭션이 서명된 후의 디지털 서명                    |
| `compression`              | `compression_type`    | 사용된 압축방식                               |
| `packed_context_free_data` | `bytes`               | 압축된 context-free 데이터 (만약 트랜잭션이 압축되었다면) |
| `packed_trx`               | `bytes`               | 압축된 트랜잭션(만약 압축되었다면)                    |
| `unpacked_trx`             | `signed_transaction`  | 압축해제되고 캐시된 트랜잭션                        |
| `trx_id`                   | `transaction_id_type` | 트랜잭션 ID                                |

트랜잭션 인스턴스가 구성된 후 캐시된 unpacked 트랜잭션을 `unpacked_trx` 필드에 보관합니다. 서명된 트랜잭션이 이미 압축되어 있는 경우 `packed_trx` 필드에서 압축이 해제되고 `unpacked_trx` 로 캐시됩니다. 서명된 트랜잭션이 압축되지 않은 상태로 저장된 경우 해당 트랜잭션은 단순히 `unpacked_trx` 에 복사됩니다. s`ignatures` 필드를 사용하면 트랜잭션을 완전히 압축 해제할 필요 없이 트랜잭션 서명을 신속하게 검증할 수 있습니다.

## 트랜잭션 라이프사이클(Transaction Lifecycle)

트랜잭션은 생성되어 사라질 때 까지 여러가지 단계를 거칩니다.&#x20;

첫째, 트랜잭션은 응응 프로그램이나 cleos 같은 Antelope  클라이언트가 어떤 액션을 사용하여 트랜잭션을 블록에 푸시하는 단계에서 생성됩니다.&#x20;

다음으로 트랜잭션은 연결된 로컬 노드로 전송되고 다시 p2p 네트워크를 통해 현재 동작중인 블록 생산자(Block Producer) 노드로 릴레이 되어 유효성 검사를 거치고 문제가 없으면 실행됩니다.&#x20;

그 다음, 일정 맞춰 동작중인 블록 생산자 (BP, Block Producer)노드가 다른 트랜잭션들과 함께 블록으로 푸시합니다.&#x20;

마지막으로 트랜잭션을 포함하고 있는 블록의 유효성을 검사하기 위해 다른 노드에 푸시됩니다. 대다수의 생산자 노드가 블록을 검증한 뒤 블록이 변경할 수 없는 상태가 되면, 비로소 이 블록은 변하지 않는 영구적인 데이터로 블록체인에 기록됩니다.

### 트랜잭션 생성

트랜잭션은 응용 프로그램에서 만들어집니다. 응용 프로그램은 트랜잭션 오브젝트를 인스턴스화하고 관련 액션 인스턴스를 트랜잭션 인스턴스 내의 목록에 푸시합니다. 액션 인스턴스에는 액션을 수행할 수신자 계정에 대한 실제 세부 정보, 작업의 이름, 서명 및 지연을 통해 트랜잭션을 승인해야 하는 행위자 및 권한 수준 목록, 보내는 메시지(있는 경우)가 포함됩니다.

#### 액션 스키마 <a href="#action-schema" id="action-schema"></a>

| Name            | Type                  | Description              |
| --------------- | --------------------- | ------------------------ |
| `account`       | `name`                | 인코딩 된 13 문자의 계정 이름       |
| `action_name`   | `name`                | 인코딩 된 13 문자의 액션 이름       |
| `authorization` | `permission_level` 배열 | `actor:permission` 인증 목록 |
| `data`          | `bytes`               | 전달할 액션 데이터               |

응용 프로그램에서 트랜잭션 인스턴스가 생성되면 처리되도록 대기열에 들어갑니다. 여기에는 트랜잭션 서명과 실제 트랜잭션을 전파하고 실행하기 위하여 서명된 트랜잭션을 로컬 노드에 푸시하는 두 가지 주요 단계가 포함됩니다. 이러한 단계는 일반적으로 Antelope 응용프로그램 내에서 수행됩니다.

### 트랜잭션 서명

트랜잭션에 포함된 모든 액션에 지정된 명시적 `actor:permission` 쌍의 누적 집합을 만족하기에 충분한 키 집합으로 트랜잭션을 서명해야 합니다. 이 링크는 지정된 권한에 대한 권한 테이블을 통해 수행됩니다([계정 및 권한: 3. 참조](https://developers.eos.io/welcome/latest/protocol-guides/accounts\_and\_permissions#3-permissions)). 실제 서명에 사용할 키는 응용 프로그램이 실행되는 클라이언트 머신 안에 있는, 서명 계정과 연결된 지갑에서 가져옵니다.

트랜잭션 서명 프로세스에는 서명할 트랜잭션 인스턴스, 응용프로그램 지갑 내의 관련 개인 키를 검색하는 공개 키 집합 및 체인 ID의 세 가지 매개 변수가 필요합니다. 체인 ID는 블록체인의 초기 구성 매개 변수에 따라 달라지는 제네시스 상태 데이터의 해시값 이며, Antelope 블록체인을 식별하는 데 사용됩니다. 트랜잭션에 서명하기 전에 Antelope 소프트웨어는 먼저 트랜잭션 다이제스트(Digest)를 계산합니다. 트랜잭션에 컨텍스트가 없는 액션이 있는 경우 다이제스트 값은 체인 ID, 트랜잭션 인스턴스 및 컨텍스트가 없는 데이터의 SHA-256 해시 값이 됩입니다. 해시 계산에 참조 필드(메모리 주소)가 포함되지 않도록 암호화 해시를 계산하기 전에 인스턴스 필드가 직렬화 됩니다. 트랜잭션 요약 계산 및 서명 프로세스가 아래에 설명되어 있습니다.

![](<../../.gitbook/assets/image (7).png>)

트랜잭션의 다이제스트(digest)를 계산한 후 이 다이제스트는 서명 계정의 공개 키와 연결된 개인 키로 서명됩니다. 공개 키-개인 키 쌍은 일반적으로 로컬 노드와 연결된 로컬 컴퓨터 내에 저장하여 사용합니다. 서명 프로세스는 서명 계정과 연결된 지갑 관리자 내에서 수행되며 일반적으로 응용프로그램을 배포하는 사용자와 동일합니다. 지갑 관리자에는 디지털 서명을 수행할 수 있는 가상의 보안구역(Secure Enclave) 이 있어서 개인 키가 지갑 밖으로 유출 될 염려 없이 메시지 서명을 할 수 있습니다. 트랜잭션은 서명이 생성된 후 서명된 트랜잭션 인스턴스에 최종적으로 추가됩니다.

## 트랜잭션 푸시

트랜잭션이 서명되고 나면 서명된 트랜잭션 인스턴스로부터 패킹된 트랜잭션 인스턴스가 생성되고 이를 응용프로그램이 로컬 노드로 푸시합니다. 그러면 트랜잭션이 활성 생산자 노드(Producer Node)로 릴레이되어 서명 확인, 실행 및 유효성 검사가 수행됩니다.&#x20;

트랜잭션을 수신하는 모든 생산자 노드는 트랜잭션을 다른 생산자 노드로 릴레이하기 전에 로컬 컨텍스트에서 실행해 보고 및 유효성 검사도 시도해 봅니다. 그 결과 유효한 트랜잭션은 릴레이되고 유효하지 않은 트랜잭션은 삭제됩니다. 이는 악의를 가진 행위자들이 가짜 트랜잭션을 만들어 네트워크에 스팸 트랜잭션을 살포하는 것을 막기 위한 아이디어 입니다. 따라서 잘못된 트랜잭션은 스케줄에 따라 활성 생산자 노드에 도달하기 전에 필터링 및 삭제될 수 있습니다.&#x20;

노드는 트랜잭션을 받을 때, 트랜잭션이 유효한 것인지 미리 추측하지 않습니다. 지금 블록을 생성하고 있는지에 관계없이 트랜잭션을 받는 생산자 노드가 모든 트랜잭션을 다시 검증합니다. 차이점이 있다면, 블록을 생산하는 노드는 스케줄에 따라 블록 생산자가 검증한 트랜잭션을 대기중인(pending) 블록에 넣은 다음, 완료된(Finalised) 블록을 자체 로컬 체인으로 푸시하고 다른 노드에 릴레이하는 방식으로 블록을 생성한다는 것입니다.

## 트랜잭션 검증

트랜잭션을 확인하는 과정은 다음과 같습니다.

첫째, 트랜잭션에 제공된 서명 집합에서 트랜잭션에 서명한 계정과 연결된 공개 키를 복구합니다. Antelope 에서 사용되는 타원 곡선 디지털 서명 알고리즘인 ECDSA(Elliptic Curve Digital Signature Algorithm) 덕분에 암호학적으로 복구가 가능합니다.&#x20;

둘째, 트랜잭션에 포함된 각 액션의 액션 권한(`actor:permission`) 목록에 지정된 각 액터의 공개 키를 복구된 키 집합과 비교하여 해당 키의 권한이 충분한지 확인합니다.&#x20;

셋째, 만족한 각 `actor:permission` 은 해당 `actor:contract::action` 쌍에 필요한 관련 최소 권한과 비교하여 해당 최소 권한을 충족하는지 또는 초과하는지를 확인합니다. 이 마지막 검사는 액션이 실행되기 전에 액션 수준에서 수행됩니다([3.4.2 권한 확인 참조](https://developers.eos.io/welcome/latest/protocol-guides/transactions\_protocol/#342-permission-check)).

### 트랜잭션 컨텍스트

공개 키가 복구되면 트랜잭션 인스턴스에서 트랜잭션 컨텍스트가 생성됩니다. 트랜잭션 컨텍스트는 각 액션이 발송되고 실행될 때 생성되는 액션 추적 및 액션 영수증을 추적합니다. 생성된 모든 상태는 트랜잭션 추적 인스턴스 및 액션 영수증 목록에 보관됩니다. 트랜잭션 추적은 액션 추적 목록으로 구성됩니다. 각 액션 추적에는 액션 수신, 액션 인스턴스, 컨텍스트가 없는 액션인지 여부, 액션을 생성한 트랜잭션 ID 등 실행된 액션에 대한 정보가 포함됩니다. 액션 영수증은 트랜잭션이 실행되고 완료된 후에 생성됩니다.

### 권한 확인

트랜잭션에 포함된 일련의 액션 전체가 원자적으로 실행되어야 하므로, Antelope 소프트웨어는 먼저 각 액션에 지정된 행위자가 해당 액션을 실행하는 데 필요한 최소 권한을 가지고 있는지 확인합니다. 이를 위해 소프트웨어는 각 액션에 대해 다음을 확인합니다.

* 각 액션 인스턴스에 지정된 각 액터의 명명된 권한.&#x20;
* 스마트 컨트랙트에 지정된 해당 행위자의 명명된 `actor:contract::action` 쌍.&#x20;

명명된 권한 집합이 스마트 컨트랙트의 해당 `actor:contract::action` 쌍에 필요한 최소 권한 수준을 충족하지 못하는 actor가 하나 이상 있으면 트랜잭션이 실패합니다.&#x20;

액션이 실행되기 전에 액션 사용 권한을 확인하는 이유는 성능 때문입니다. 몇 가지 액션이 실행된 후 취소하는 것보다 모든 액션을 실행하지 않은 상태에서 트랜잭션을 취소하는 것이 더 효율적이지만 나중에 실패한 액션 또는 권한 부여의 결과로 롤백됩니다. 실패한 액션 중에 발생한 모든 상태 변경은 데이터 무결성을 유지하기 위해 실행 취소해야 합니다. 데이터베이스 세션은 메모리 사용량 및 컴퓨팅 리소스 측면에서 비용이 많이 들기 때문에 실행을 취소하는 작업은 가능한 한 최소화해야 합니다.

### 액션 인스턴스

아래 다이어그램은 액션 인스턴스를 보여줍니다. 수신자 계정, 액션 이름, 행위자 목록 및 권한, 수신자 계정으로 보낼 메시지가 포함된 액션 데이터로 구성됩니다.

![](<../../.gitbook/assets/image (3) (1).png>)

### 인증 확인

최소 권한 수준을 확인한 후 액션 인스턴스 내의 각 행위자의 권한과 일치하는 수신자 계정의 권한 테이블을 확인합니다([계정 및 권한: 3 참조](https://developers.eos.io/welcome/latest/protocol-guides/accounts\_and\_permissions#3-permissions)). 자세한 내용은 사용 권한을 참조하십시오.

## 트랜잭션 실행

트랜잭션을 실행하기 위해 체인 데이터베이스 세션이 시작되고 스냅샷이 생성됩니다. 이렇게 하면 트랜잭션 액션이 실패할 경우 체인 상태에 대한 변경 내용을 롤백할 수 있습니다. 해당 트랜잭션 컨텍스트는 실행 중에 트랜잭션 상태를 유지합니다. 트랜잭션을 실행하기 위해 해당 트랜잭션 인스턴스와 관련된 각 액션이 실행을 위해 디스패치됩니다. 컨텍스트가 없는 액션이 있는 경우 먼저 디스패치 된 후 일반 액션들이 실행됩니다.

### 컨택스트 적용

액션 실행을 준비하기 위해 각각의 액션을 위한 적용 컨텍스트(Apply Context) 인스턴스가 로컬에서 생성됩니다. 적용 컨텍스트는 이름에서 알 수 있듯이 작업을 적용하는 데 필요한 리소스(예: [네트워크 피어 프로토콜: 2.2. 체인 컨트롤러 참조](network-peer-protocol.md)), 상태를 유지하는 체인 데이터베이스, 트랜잭션이 실행되는 트랜잭션 컨텍스트, 실제 액션 인스턴스 및 수신자 계정에 대한 참조를 포함합니다.

### 액션 추적(Action Trace)

각 액션을 준비하여 실행하기 위해 액션 영수증(Action Receipt) 및 액션 추적 인스턴스가 모두 초기화됩니다.&#x20;

먼저 액션 인스턴스 자체의 해시가 계산되어 액션 영수증에 저장됩니다.&#x20;

다음으로 액션을 포함하는 트랜잭션이 푸시될, 대기 중인 블록에 대한 통계를 사용하여 액션 추적을 초기화 합니다. 따라서 액션 추적을 통해 실제 블록과 블록을 생성한 실제 노드를 포함하여 해당 액션을 포함하는 트랜잭션을 추적할 수 있습니다.&#x20;

마지막으로, 액션 핸들러는 핸들러 이름, 수신기 계정 및 행위자 계정을 생산 노드 내의 체인 컨트롤러에 의해 유지되는 액션 핸들러 목록과 일치시킴으로써 찾을 수 있습니다. 이러한 액션 핸들러는 시스템 컨트랙트 및 클라이언트 응용 프로그램이 로드될 때 컨트롤러에 적용됩니다. 핸들러는 수신자 계정 이름, 컨트랙트 이름, 액션 이름 및 액션 핸들러를 받습니다.

### 액션 실행(Action Execution)

적절한 액션 핸들러를 찾으면 화이트리스트 및 블랙리스트를 확인합니다. 노드가 현재 블록을 생성하고 있는 경우 계정 화이트리스트 및 블랙리스트(있는 경우)에서 수신자 계정을 검사하고, 그 다음 액션 블랙리스트가 있으면 액션이 블랙리스트에 올라와 있는지 확인 합니다. 수신자 계정 또는 액션 이름이 블랙리스트에 있으면 액션은 중단됩니다.&#x20;

수신자 계정이 이미 화이트리스트에 있으면 블랙리스트 검사는 건너뜁니다. 모든 검사를 통과하면 해당 액션 핸들러를 호출하여 액터 계정을 from 매개 변수에 전달하고 수신 계정을 to 매개 변수에 전달하여 최종적으로 액션이 실행됩니다.

## 트랜잭션 마무리(Finalise Transaction)

트랜잭션에 포함된 모든 액션이 실행된 후 트랜잭션은 완료 단계로 들어갑니다. 이 단계에서는 각 액션에 대해 해당하는 액션 영수증이 생성됩니다. 액션 영수증에는 해당 액션 인스턴스의 해시, 분석에 사용되는 몇 개의 카운터 및 해당 액션의 수신자 계정(해당하는 경우)이 포함됩니다.

### 트랜잭션 영수증(Transaction Receipt)&#x20;

트랜잭션에 대한 모든 액션 영수증이 생성된 후 트랜잭션 영수증이 블록에 포함된 다른 트랜잭션 영수증과 함께 최종적으로 생성되고 서명된 블록에 푸시됩니다. 트랜잭션 영수증에는 트랜잭션 결과(실행, 미실행, 실패, 지연, 만료 등)와 청구된 CPU 사용량(ms 단위), 사용된 총 NET 스토리지(아래 transaction\_receipt 스키마 참조)를 요약한 정보를 담고 있습니다.

**ransaction\_receipt schema**

| Name              | Type           | Description             |
| ----------------- | -------------- | ----------------------- |
| `status`          | `uint8_t`      | 트랜잭션 실행 시도의 결과          |
| `cpu_usage_us`    | `uint32_t`     | 총 CPU 사용량(ms)           |
| `net_usage_words` | `unsigned int` | 총 NET 사용량(64-bit words) |
| `trx`             | `variant`      | 트랜잭션 ID 또는 패킹된 트랜잭션     |

`status` 필드는 다음과 같은 결과를 나타내는 8 비트의 열거형(enumeration) 타입을 가집니다.

* `executed` - 트랜잭션 성공, 에러 핸들러 실행되지 않음.
* `soft_fail` - 트랜잭션 실패, 에러 핸들러 성공.
* `hard_fail` - 트랜잭션 실패, 에러 핸들러 실패.
* `delayed` - 나중에 실행하기 위해 사용자가 트랜잭션을 지연시킴.
* `expired` - 트랜잭션 만료됨. CPU/NET 이 사용자에게 반환됨.

{% hint style="info" %}
**'delayed' 상태**

`delayed` 상태는 미뤄진 사용자 트랜잭션(**delayed user transactions)** 에만 적용됩니다. 미뤄진 사용자 트랜잭션이란 인증 조건을 만족시키기 위해 지연된, 사용자가 명시적으로 작성한 트랜잭션입니다. ( [3.6.3. Delayed User Transactions](https://developers.eos.io/welcome/latest/protocol-guides/transactions\_protocol/#363-delayed-user-transactions) 참조).
{% endhint %}

trx 필드에는 트랜잭션 ID 또는 패킹된 트랜잭션 자체가 포함됩니다. 실제 선택은 트랜잭션 유형에 따라 다릅니다. 지연된 트랜잭션(Deferred Transaction) 및 미뤄진 사용자 트랜잭션(Delayed User Transaction)에서 생성된 영수증은 트랜잭션 ID별로 저장되며, 다른 모든 유형은 패킹팩된 트랜잭션으로 저장됩니다.

### 지연된 트랜잭션

지연된 트랜잭션은 블록체인을 처리할 때의 부작용 때문에 발생하므로 해당 상태는 블록이 아닌 체인 데이터베이스에 저장됩니다. 따라서 트랜잭션 영수증에 명시적으로 내용을 포함할 필요가 없습니다. 모든 동기화 노드는 지연된 트랜잭션의 형태를 합의 사항으로 인식해야 합니다. 스마트 컨트랙트에 의해 발행된 지연 트랜잭션은 트랜잭션 영수증의 `delayed` 상태 필드에 아무런 역할을 하거나 영향을 미치지 않습니다.

{% hint style="warning" %}
**Deprecation 알림**

지연된 트랜잭션은 EOSIO 2.0 에서 depreciated(사용 중지 권고) 처리 되었습니다. 지연된 트랜잭션의 동작에 대하여는 CDT 문서의 [Deferred Transactions](https://developers.eos.io/manuals/eosio.cdt/latest/best-practices/deferred\_transactions) 단원을 참조하시기 바랍니다.)
{% endhint %}

### 지연된 사용자 트랜잭션(Delayed User Transaction)

지연된 사용자 트랜잭션에는 지연 타이머 시작 시 네트워크에 푸시될 때 패킹된 트랜잭션이 포함됩니다. 그러나 일반 트랜잭션과 달리 "지연" 상태가 유지되므로 실행 및 유효성 검사가 연기될 수 있습니다. 나중에 실행/실패/만료(지연 타이머 종료 시)할 때 트랜잭션 ID만 포함되는데, 이는 동기화 된 노드에 이미 이전에 브로드캐스트된 블록의 트랜잭션 콘텐츠가 있기 때문입니다.

## 트랜잭션유효성 확인(Validate Transaction)

트랜잭션은 수명 주기 동안 여러가지 단계에서 확인 및 검증됩니다. 먼저 P2P 네트워크에서 느슨한 트랜잭션으로 전파됩니다([3.4 트랜잭션 검증 참조](https://developers.eos.io/welcome/latest/protocol-guides/transactions\_protocol/#34-verify-transaction)). 블록 유효성 검사 중에 블록이 다수의 블록 생성자 사이에서 확인되므로 트랜잭션 검증 중, 그리고 재생 중에 트랜잭션을 완전히 재검증하도록 구성된 경우 선택적으로 블록체인 재생 중에 블록이 확인됩니다.&#x20;

기본적으로 기록된 트랜잭션은 재생 중에 완전히 재검증되지 않습니다. 노드 운영자가 로컬 블록 로그에 대한 신뢰를 개인적으로 또는 사이드 채널을 통해 설정했기 때문에 더 이상 비잔틴 정보의 잠재적 소스로 간주되지 않습니다.

### 유효성 검증 프로세스

블록의 일부로 트랜잭션을 검증할 때 다양한 수준에서 여러 유효성 검사가 수행됩니다. 전체 블록 유효성 검사에서 블록에 기록된 모든 트랜잭션이 재생되고 로컬에서로 계산된 머클 트리 루트 해시(Markle Tree Root Hashes, 각각 트랜잭션 수신 데이터 와및 액션 수신 데이터에서 생성됨)를 블록 헤더의 `transaction_mroot` 및 `action_mroot` 필드와 비교합니다. 따라서 기록된 트랜잭션이 블록 내에서 변조되면 머클 트리 루트 해시가 일치하지 않을 뿐만 아니라 트랜잭션 서명 유효성 검사에도 실패하게 됩니다. 악의를 가진 블록 생성자가 트랜잭션을 조작하였다면 블록 서명도 검증에 실패합니다([컨센서스 프로토콜: 5.3. 블록 검증 참조](https://developers.eos.io/welcome/latest/protocol-guides/consensus\_protocol#53-block-validation)).
