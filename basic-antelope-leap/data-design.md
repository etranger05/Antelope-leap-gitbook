---
description: Data design
---

# 데이터 설계

확장 가능하고 많은 데이터를 효율적으로 처리해야 하는 애플리케이션을 구축하려면 적절하게 데이터 설계를 해야 합니다. 특히 Antelope 스마트 컨트랙트 개발자는 여러 가지 한계에 직면할 것이므로 적절한 데이터 설계가 훨씬 더 중요해 집니다.

다음은 스마트 컨트랙트 프로젝트를 설계할 때 일반적으로 고려해야 할 사항들입니다.

* 컨트랙트 데이터에 무엇을 저장해야 하는가. 그리고 블록체인 외부에는 무엇을 저장해야 하는가.
* 컨트랙트는 데이터 요소를 찾기 위해 어떤 질의를 실행해야 하는가. 이러한 질의에 대한 인덱스를 구성해야 한다.
* 블록체인 클라이언트가 필요한 데이터를 찾기 위해 어떤 질의를 실행할 것인가. 이러한 질의에 대한 인덱스를 추가하거나 데이터를 검색하는 오프체인 메소드를 찾아야 할 수도 있다.&#x20;
* 실제로 작동하는 인덱스를 어떻게 구성할 것인가.&#x20;
* 데이터 모델은 완성되었는가. 이 장에서 자세히 설명했듯이, 데이터 구조를 수정하는 것은 비용이 많이 드는 프로세스이다.

## Antelope 컨트랙트 데이터 스토어

보통 스마트 컨트랙트 "테이블"이라고 이야기하지만 실제로는 바이너리 트리입니다. 룩업 키는 정렬된 셋(set)에 저장되며 어떤 요소를 찾아야 하는 상황이 되면 이진 검색을 수행합니다.&#x20;

이는 또한 어떠한 범위 내에서 키를 효율적으로 셀 수 없다는 것을 의미합니다. 키를 세어보려면 각 키를 방문해야 합니다.&#x20;

데이터 모델을 더 잘 이해하려면 Antelope CDT 의 일부인 `multi_index.hpp` 안을 살펴보면 도움이 될 수 있습니다. 패키지에서 CDT를 설치한 경우 `/usr/opt/eosio.cdt/1.8.1/include/eosolib/contracts/eosio/`에서 찾아볼 수 있습니다. 일반적으로 코드의 동작 방식을 이해하려면 CDT와 함께 제공되는 헤더 파일을 살펴보는 것이 좋습니다.&#x20;

스마트 컨트랙트 데이터 상호 작용의 가장 중요한 부분은 네임스페이스 `internal_use_do_not_use` 라는 재미있는 이름을 가진 장소에 정의되어 있습니다. 이 네임스페이스 내부에는 여러 내장함수와 nodeos 가 WASM 가상 머신으로 내보낸 함수들이 있습니다.&#x20;

안타깝게도 헤더에는 이러한 하위 수준의 함수까지 설명되어 있지는 않으므로 nodeos 소스의`libraries/chain/include/eosio/chain/webassembly/interface.hpp`에서 해당 기능을 살펴봐야 합니다. 사실 이러한 함수가 정의하는 것은 nodeos 에 의해 관리되는 컨트랙트 데이터에 대한 저수준 접근 방식입니다.

이 함수는 컨트랙트 테이블에 행을 만들 때 어떤 일이 일어나고 있는지 잘 보여줍니다.

```
 int32_t db_store_i64(uint64_t scope, uint64_t table, 
                      uint64_t payer, uint64_t id, 
                      legacy_span<const char> buffer);
```

보시다시피 테이블의 행에 들어가는 값은 바이트를 추상화 한 벡터 값입니다. 그래서 노드는 테이블 안에 저장된 구조에 대해 아무것도 알지 못합니다. 행은 코드, 스코프(scope), 테이블 이름 및 Primary Key 값을 조합하여 고유성을 가지게 됩니다.(`db_store_i64` 는 code (코드를 실행하기 위한 컨트랙트 계정)을 가지고 있지 않습니다. 왜냐하면 컨트랙트에게 허용된 것은 테이블을 업데이트 하기 위한 액션 뿐이기 때문입니다. 그러나 db\_find\_i64 및 db\_lowerbound\_i64 에서는 전체 quardruple 을 볼 수 있습니다.  함수는 행의 내용을 검색할 수 있는 32비트 반복자(iterator)를 반환합니다.(db\_get\_i64 참조).&#x20;

interface.hpp 에서 db\_idx64\_stor 와 같이 보조 인덱스에 접근하는 함수를 찾을 수 있습니다(예: db\_idx64\_store). 여기서 다음과 같이 두 가지 중요한 사항을 알 수 있습니다.&#x20;

* 보조 인덱스는 테이블 행과 별도로 업데이트 됩니다. 그러나 CDT의 C++ `multi-index` 클래스는 행이 업데이트될 때마다 보조 인덱스를 업데이트해 주는 래퍼를 제공하고 있기 때문에 개발자는 이 사실을 알 수 없습니다.&#x20;
* 인수 목록을 보면 보조 인덱스를 관리하는 각 함수는 각 유형의 인덱스를 하나만 참조할 수 있는 것을 볼 수 있습니다. 그러나 우리는 동일한 유형의 인덱스를 여러 개 생성할 수 있다는 것을 이미 알고 있습니다. `multi_index` 클래스는 테이블 이름의 상위 4비트를 사용하여 주어진 테이블에 대해 동일한 유형의 여러 인덱스를 만듭니다. 그렇기 때문에 테이블 이름은 절대 13개의 기호로 구성될 수 없으며 12개의 기호가 최대값입니다.

`multi_index.hpp` 의 더 아래쪽으로 내려가면 `multi_index` 클래스 정의를 볼 수 있습니다. multi\_index 클래스 정의는 이러한 저수준 호출을 위한 편리한 프로그래밍 인터페이스를 제공합니다.&#x20;

이 헤더 파일을 살펴보면 다음과 같은 몇 가지 흥미로운 사실을 알 수 있습니다.&#x20;

1. 테이블 행은 클래스 메서드 또는 반복자를 통해 액세스할 때마다 항상 저장소에서 검색되고 역직렬화 됩니다.&#x20;
2. 하지만 캐시가 있기 때문에 항상 그렇지는 않습니다. 다중 인덱스 객체는 검색된 행을 기억하고 다음 읽기에 반환합니다. 이렇게 하면 동일한 행에 여러 번 액세스할 경우 작업 속도가 빨라집니다. 그러나 다중 인덱스의 두 인덱스가 동일한 테이블을 참조하는 경우 행을 수정하거나 삭제하면 예기치 않은 효과가 발생할 수 있습니다. 경험상 동일한 액션을 실행할 때 동일한 테이블에 대해 다중 인덱스 개체를 여러 개 만들지 않도록 하는 것이 좋습니다.&#x20;
3. 행을 지울 때마다 반복자의 다음 행이 컨트랙트 저장소에서 검색됩니다. 따라서 행 지우기는 값싼 작업이 아닙니다. 액션에서 한 행을 삭제하더라도 액션이 실행될 때 적어도 두 개 이상의 행을 검색되기 때문입니다.

또한 호기심 많은 독자를 위한 생각의 음식입니다.&#x20;

* 컨트랙트 테이블의 데이터는 표준 방식으로 직렬화될 필요가 없습니다. 노드는 바이트 벡터의 내부를 신경 쓰지 않습니다. 물론 HTTP API 와 히스토리 인덱스는 중요하기 때문에 개발자는 데이터를 저장하는 다른 방법을 선택할 수 있습니다.&#x20;
* 보조 인덱스는 이론적으로 가능하지만 표준 다중 인덱스가 모든 행에 대해 자동으로 보조 인덱스 항목을 만들기 때문에 다른 클래스가 필요합니다. 예를 들어 테이블에는 boolean 플래그가 있으며 이 플래그가 true 인 행에만 액세스할 수 있게 만드는 식 입니다. 이론적으로 보조 인덱스가 이 플래그가 설정된 행만 취급하는 경우라면 RAM을 크게 절약할 수 있습니다. 유일한 문제는 이 방법을 실행할 수 있는 실전 테스트를 거친 라이브러리가 없다는 것입니다.

## 데이터 구조 계획하기

데이터 테이블의 구조를 계획할 때는 다음과 같은 몇 가지 다른 측면을 고려해야 합니다.&#x20;

* 메모리 및 CPU는 비용이 들기 때문에 테이블에는 스마트 컨트랙트와 애플리케이션에 필요한 필수 데이터만 저장하면 됩니다. 블록체인 외부에서만 사용되는, 크기가 큰 데이터는 sha256 해시 또는 IPFS URL로 참조하도록 하고 다른 곳에 저장할 수 있습니다.&#x20;
* 테이블 행을 읽을 때는 항상 세 가지 단계가 있습니다.&#x20;
  * nodeos 상태 메모리에서 name, scope, contract 를 사용하여로 테이블을 찾습니다. 로그 시간 복잡도(Logarithmic Complexity)를 가집니다.
  * 기본 인덱스 나 보조 인덱스를 사용하여 테이블 내의 행을 찾습니다. 이는 로그 시간 복잡도를 가집니다만, 보조 인덱스가 포함된 경우, 먼저 보조 인덱스에서 기본 키를 검색한 다음, 기본 키로 행을 검색합니다.&#x20;
  * nodeos 상태 메모리에서 행을 읽고 컨트랙트 내에서 역직렬화합니다. 이는 항목의 크기에 비례하여 선형 시간 복잡도(Linear Complexity)를 가집니다.
* 테이블 행을 작성하는 것은 읽기와 거의 동일하지만 보조 인덱스 때문에 약간 더 복잡합니다. 행을 직렬화 한 다음 주어진 기본 키를 사용하여 nodeos 상태 메모리에 배치한 다음에 나머지 모든 보조 인덱스를 업데이트 해야 합니다.&#x20;
* 행을 삭제하는 것도 저렴하지 않습니다. multi-index 반복자가 먼저 전체 행을 로드하고나서 반복자에서 다음 행을 읽은 뒤, 행과 보조 인덱스를 삭제하고 다음 레코드를 가리키는 반복자를 반환합니다. 그래서, 행 삭제는 읽는 것보다 두 배나 더 비용이 들어갑니다.
* 각 행에 대해 내부 nodeos 구조에 대한 RAM 오버헤드가 있습니다. 기본 인덱스 와 보조 인덱스 각각 약 100바이트 정도가 됩니다. 또한 테이블의 첫 번째 행은 트리 구조를 위해 nodeos 내부에 더 많은 공간을 할당해야 합니다. RAM 비용을 추정하는 가장 좋은 방법은 컨트랙트를 테스트넷에서 실행해보고 소비량을 측정하는 것입니다.

Antelope 은 테이블 필드를 벡터로 정의할 수 있습니다. 벡터는 기본적으로 같은 타입의 데이터 요소를 선형적으로 배열한 것 입니다. 벡터는 액션 실행 시 필요한 일련의 요소들을 저장하는 데 매우 편리합니다. 하지만 한가지 단점이 있는데, 테이블에서 한 줄의 데이터를 읽거나 쓸 때마다 전체 벡터를 처리해야 합니다. 크기에 제한이 없는 경우, 트랜잭션 실행 제한 시간인 30ms 가 전체 벡터를 읽기에 충분하지 않은 상황에 처할 수도 있습니다. 또한 CDT의 multi-index 구현에서는 행을 먼저 읽지 않고는 삭제할 수도 없습니다.&#x20;

따라서 벡터는 신중하게 살펴봐야 합니다. 합리적인 한계 내의 길이를 가지는 것이 보장되는 경우에만 벡터를 사용하는 의미가 있습니다. 그렇지 않으면 데이터 구조를 리팩터링하고 모든 요소를 별도의 테이블 행에 보관해야 합니다.

## 인덱스 설계하기

각 컨트랙트 테이블에는 고유한 uint64\_t 타입의 기본(Primary) 인덱스가 있어야 합니다. Antelope 소프트웨어는 기본 인덱스 값이 같은 두 행을 삽입할 수 없습니다. 64비트는 180억 개의 조합을 생성하는데, 이는 실제 사용하기에 매우 큰 숫자입니다.&#x20;

기본 인덱스와 보조 인덱스는 모두 테이블 행의 함수로 정의됩니다. 대부분의 경우 이러한 함수는 하나의 필드 값만 반환하지만 꼭 그럴 필요는 없습니다. 작업에 따라 좀 더 복잡한 방법으로 인덱스 값을 계산할 수 있습니다.&#x20;

다음과 같이 테이블에서 기본 인덱스를 정의하는 일반적인 방법이 몇 가지 있습니다.

* 테이블에 계정당 하나의 행만 있는 경우 계정 이름을 기본 인덱스로 사용합니다.&#x20;
* 다중 인덱스 클래스의 `available_primary_key()` 메소드를 사용하여 값이 자동으로 증가하게 합니다. 이 메소드는 기존 행의 기본 키보다 하나 높은 정수를 반환합니다. 주의점이 있는데, 맨 윗줄의 행이 삭제되면 이 메서드는 기본 키를 재사용합니다.&#x20;
* 자동으로 증가하는 정수값을 다른 테이블에 저장하고 새 행마다 값을 증가시킵니다. 이렇게 하면 ID가 재사용되지 않습니다.&#x20;
* 행의 특정 값에서 sha256 해시의 처음 8바이트를 가져옵니다. 물론 이것이 100% 고유성을 보장하지는 않겠지만, 충돌 가능성은 매우 희박합니다.&#x20;
* 테이블에 행을 삽입하는 트랜잭션 ID의 처음 8바이트를 사용합니다. 이 방법의 이점은 트랜잭션에 서명한 클라이언트가 레코드의 저장 위치를 이미 알고 있으며 추가 처리를 위해 레코드를 질의하여 가져올 수 있다는 것입니다. JavaScript 정수는 48비트보다 약간 더 큰 수의 비트만 처리할 수 있으므로 인덱스에 6바이트를 사용하거나 BigInt를 사용해야 합니다. 그렇다고 해도 이미 6바이트는 인덱스 수십억 개를 만들 수 있는 엄청나게 많은 양입니다.
* 기본 인덱스는 다른 테이블의 기본 인덱스를 참조할 수 있습니다. 예를 들어, 테이블 A에는 한번 만들어지면 절대 변경되지 않는 벌크 데이터가 저장된 긴 행이 있고, 테이블 B 는 자주 변경되는 A 행의 속성을 저장하는 짧은 행을 가집니다. 이렇게 하면 추가 RAM 비용을 들여 A를 직렬화 하는데 필요한 CPU 시간을 절약할 수 있습니다.

몇 가지 추가된 기준으로 보조 인덱스를 사용하여 행을 찾는 방법이 있습니다. 대부분의 경우 행 구조에 있는 일부 필드의 값일 뿐이지만 해시 또는 조건부처럼 행 필드의 더 복잡한 함수가 될 수도 있습니다. 보조 인덱스 값이 너무 많은 행을 참조할 경우 실용적이지 않거나 아예 사용할 수 없게 됩니다.&#x20;

예제를 살펴보겠습니다. 테이블은 어떤 도시의 모든 학생 데이터를 가지고 있으며 `school_id` 는 학생이 어느 학교에 다니는지 식별합니다.

```
  struct [[eosio::table("students")]] student_row {
    name            account;     // student's personal account
    uint32_t        school_id;   // school identifier
    auto primary_key()const { return account.value; }
    uint64_t by_school_id()const { return school_id; }
  };

  typedef eosio::multi_index<
    name("students"), student_row ,
    indexed_by<name("school"), const_mem_fun<student_row, 
               uint64_t, &student_row::by_school_id>>,
    > students;
```

반복자로 학교에 다니는 모든 학생을 순회한다면, 요청은 실패할 가능성이 높습니다. 트랜잭션 만료까지는 30ms 밖에 없고 HTTP API 요청에는 10ms 의 제한이 있습니다. 그렇기 때문에 소수의 학생들만을 반복하여 가져오는 방법을 사용해야 합니다. 그리고 다음에 다시 반복자를 시작할 때, 반복자는 다시 이 학교의 첫 번째 학생을 가리키게 될 것입니다.&#x20;

따라서 이 예제에서 보조 인덱스는 두 가지 기준을 충족해야 합니다. 어떤 학교에 해당하는 테이블의 첫 번째 레코드를 빠르게 가리키고 필요한 만큼의 행을 여러 번 반복하여 가져올할 수 있는 방법이 필요합니다. 마지막으로 처리된 위치부터 시작하려면 보조 인덱스의 값을 기억할 수 있어야 합니다. 이 예에서 128비트 인덱스는 다음을 지원합니다.

```
  struct [[eosio::table("students")]] student_row {
    name            account;     // student's personal account
    uint32_t        school_id;   // school identifier
    auto primary_key()const { return account.value; }
    uint128_t by_school_and_student()const { 
      return ((uint128_t)school_id << 64)|(uint128_t)account.value) ; }
  };

  typedef eosio::multi_index<
    name("students"), student_row ,
    indexed_by<name("school"), const_mem_fun<student_row, 
               uint128_t, &student_row::by_school_and_student>>,
    > students;
```

여기서 128비트 "school" 인덱스 상위 64비트의 학교 ID와 하위 64비트의 기본 키 복사본을 가집니다. 따라서 모든 행에는 보조 인덱스의 고유한 값이 있으며, 이 값을 살펴볼 때마다 인덱스 클래스에서 `lower_bound()` 메서드를 사용하여 원래 위치로 돌아갈 수 있습니다.&#x20;

180억 개의 조합이 학생 ID로 사용하기엔 지나치게 많다고 생각할 수 있습니다. 줄여서 32비트 정수를 사용해도 40억 개의 조합을 만들어 낼 수 있으며, 그마저도 심지어 한 나라의 모든 학생들이 사용하기에도 너무 많습니다. 따라서 이 테이블은 기본 키에 uint32\_t를 사용하여 보다 컴팩트한 방식으로 설계될 수 있습니다. 그러면 두 개의 32비트 정수가 64비트 보조 인덱스에 들어갑니다. 모든 학생이 자신의 블록체인 계정을 가지고 있어야 한다면 아래와 같이 "student" 테이블에 계정 필드와 보조 인덱스를 추가할 수 있습니다. 그런 다음 레코드를 추가하는 액션은 보조 인덱스의 고유성을 확인해야 합니다.

```
  struct [[eosio::table("students")]] student_row {
    uint32_t        student_id;  // unique student ID, managed by some authority
    name            account;     // student's personal account
    uint32_t        school_id;   // school identifier
    auto primary_key()const { return account.value; }
    uint64_t by_school_and_student()const { 
      return ((uint64_t)school_id << 32)|(uint64_t)student_id) ; }
    uint64_t by_account()const { return account.value ; }
  };

  typedef eosio::multi_index<
    name("students"), student_row ,
    indexed_by<name("school"), const_mem_fun<student_row, 
               uint64_t, &student_row::by_school_and_student>>,
    indexed_by<name("account"), const_mem_fun<student_row, 
               uint64_t, &student_row::account>>,
    > students;
```

## 테이블 스코프(Table Scope)

테이블 이름과 테이블의 기본 인덱스는 2차원 데이터 공간을 형성합니다. 여기에 하지만 스코프라고 불리는 세 번째 차원이 추가됩니다. 초기 EOSIO 설계에서 스코프는 트랜잭션 실행을 병렬화하는 데 사용할 예정이었지만 나중에 너무 복잡하다고 간주되었습니다. 그래도 여전히 스코프는 남아 있었습니다.&#x20;

스코프는 64비트 정수로 정의됩니다. 컨트랙에 테이블의 인스턴스가 하나만 필요한 경우 범위를 0으로 설정하거나 컨트랙트의 계정 이름으로 설정할 수 있습니다. 두 가지 방식 모두 유효하며, 현재 추세는 스코프에 0을 사용하는 것입니다.&#x20;

테이블 간에 복잡한 관계를 구축해야 하는 경우에도 스코프를 사용할 수 있습니다. 스코프를 사용하여 테이블을 작은 테이블 세트로 분할할 수 있으며 기본 키는 분할된 테이블 사이에서 중첩될 수 있습니다. 그러나 한 가지 한계점이 있는데  테이블에 액세스하는 순간에 스코프 값을 알고 있어야 하기 때문에 스마트 컨트랙트는 테이블 스코프들을를 순회할 수 없다는 것입니다.

표준 eosio.token 컨트랙트는 각 계정의 잔액에 대해 분리된 스코프를 사용합니다. 이는 병렬 트랜잭션을 염두에 두었던 시절의 디자인이었지만며, 이제는 대체 가능한 토큰(fungible token)에 대한 사실상의 표준이 되었습니다. 이러한 설계의 단점은 테이블의 첫 번째 행과 관련된 오버헤드 때문에 모든 계정 레코드가 메모리에서 200바이트 이상을 차지한다는 것입니다(여기서 모든 스코프는 하나의 단일 행 테이블을 가집니다).

## 테이블에 질의하기

스마트 컨트랙트 내에서 테이블에 액세스할 때 데이터가 메모리에 저장되는 방법을 기억해야 합니다. Boost C++ 라이브러리와 유사한 multi-index 오브젝트를 조작하여 반복자로 역직렬화된 테이블 행에 액세스할 수 있습니다. 반복자가 다른 행을 가리켜야 할 필요가 있을 때마다 위에서 설명한 대로 저수준의 함수를 사용하여 직렬화된 행을 검색하고, 컴파일된 구조 정의를 사용하여 역직렬화합니다. multi-index 오브젝트도 내부 캐시를 유지 관리하므로 동일한 행을 다시 읽을 경우 검색 및 역직렬화 단계를 건너뜁니다.&#x20;

기본 인덱스와 보조 인덱스는 모두 필요한 행을 찾기 위한 동일한 작업 집합을 제공합니다. 또한 두 경우 모두 인덱스가 가장 낮은 숫자값에서 가장 높은 숫자값으로 정렬됩니다. 인덱스 클래스는 다음과 같은 검색 방법을 제공합니다.

* `begin()` 은 인덱스에서 키 값이 가장 작은 항목을 가리키는 반복자를 반환합니다. 인덱스가 비어 있으면 반환되는 값은 `end()` 와 같습니다.&#x20;
* `end()`는 가장 큰 항목의 다음 항목을 가리키는 반복자를 반환합니다. 즉 유효하지 않은된 항목이며 이 반복자로 데이터에 액세스하려고 하면 예외 오류가 발생합니다.&#x20;
* `find(key)` 및 `require_find(key, errmsg)`는 키 값과 정확히 일치하는 요소를 찾습니다. 두 번째 형태는 단순히 `find()`와 `check()` 호출을 조합하는 것입니다. non-unique 보조 인덱스의 경우 어떤 일치된 요소가 반환되는지 보증하지 않으므로 여러 값을 traverse 하는 데 적합하지 않습니다.&#x20;
* `get(key, errmsg)`은 반복자를 반환하지 않고 행 구조에 대한 참조를 반환합니다. 큰 차이는 없지만 `find()`보다 편리할 수 있습니다.&#x20;
* `lower_bound(key)`는 정확한 키 값을 모르는 인덱스에 액세스하는 데 사용됩니다. 지정된 키 값보다 크거나 같은 첫 번째(가장 낮은) 요소를 반환합니다. 테이블 행의 범위를 반복해야 할 때마다 일반적으로 하한에서 루프를 시작하고 반복자가 증가할 때마다 반환된 행이 여전히 원하는 범위 내에 있는지 확인합니다. 뒤에서 예시를 들겠습니다.
* `upper_bound(key)`는 EOSIO 설명서의 오류로 인해 많은 혼란을 일으켰습니다. 가장 잘 된 설명은 nodeos에서 이 호출을 구현한 Boost 라이브러리의 정의입니다. \
  x보다 큰 키 값을 가진 첫 번째 요소를 가리키는 반복자를 반환하거나, 이러한 요소가 존재하지 않는 경우 end()를 반환합니다. 대부분의 경우 `lower_bound` 호출만 사용하지만, 거의 드물게 `upperbound` 호출이 필요할 때도 있습합니다

## 테이블 구조 변경하기

위에서 설명한 것처럼 테이블 행은 컨트랙트에 의해 직렬화된 바이트 타입 벡터입니다. 직렬화 형식은 구조를 수정할 수 있고 이전 행을 읽을 수 있을 만큼 유연하지 않습니다. 또한 보조 인덱스는 행을 삽입하거나 수정할 때만 업데이트 됩니다.&#x20;

따라서 표준 CDT 클래스를 사용하여 테이블의 필드를 수정하거나 보조 인덱스 정의를 수정해야 한다면 빈 테이블에서만 수정할 수 있습니다. 테이블을 스캔하고 각 행에 변경 사항을 적용하는 저수준의 반복자를 구현할 수는 있지만 그러면 마이그레이션 시 테이블을 사용할 수 없게 됩니다. 마이그레이션 컨트랙트가 테이블을 다시 쓰는 경우(예: 각 행을 새 테이블로 복사하고 이전 행을 지우는 경우) 원래 RAM 지급인에 대한 정보가 손실되므로 마이그레이션된 데이터 행은 관리자 계정 또는 컨트랙트 자체를 RAM 지급인으로 취급합니다.&#x20;

경우에 따라 원래 테이블과 동일한 기본 인덱스 값에 대한 추가 데이터를 제공하는 테이블을 더 만드는 것으로 충분할 수 있습니다. 단점은 추가된 행을 조회할 때에는 더 많은 CPU 시간이 필요하다는 것입니다.
