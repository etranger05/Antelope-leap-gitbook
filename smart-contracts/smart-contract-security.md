---
description: Smart Contract Security
---

# 스마트 컨트랙트 보안

## 토큰 컨트랙트 확인

구 버전의 CDT 는 `apply()` 핸들러를 위한 적절한 래퍼를 제공하지 않았기 때문에 컨트랙트 작성자들은 통지에 더 많은 주의를 기울여야 했습니다. 현재 CDT는 미리 정의된 매크로로 이러한 메커니즘을 검사합니다만, 아직까지도 다음과 같은 범용 알림 수신기를 만드는 것도 가능합니다.

```
[[eosio::on_notify("*::transfer")]] 
  void on_payment (name from, name to, asset quantity, string memo) {...}
```

이렇게 하면 트랜잭션이 오는 곳 또는 가는 곳에 대한 모든 `transfer` 액션 통지를 처리합니다. 통지는 표준 토큰 계약 또는 토큰 동작을 시뮬레이션 하는 특수하게 조작된 컨트랙트에서 나올 수 있습니다. 그러므로, 지불이 유효하다고 가정하기 전에, 반드시 원하는 토큰 컨트랙트 인지 확인할 필요가 있습니다. 컨트랙트 계정은 `get_first_receiver()`를 호출하여 찾을 수 있습니다.&#x20;

어떤 토큰 컨트랙트는 여러 통화를 취급하기 때문에 심볼을 quantity 로 검증하는 것도 중요합니다.

## to == \_self 임을 확인

transfer 알림에서, 많은 컨트랙트 작성자가 공통적으로 논리적 오류를 범한 것은, 만약 from 이 내가 아닌 경우, 그것은 나를 위한 지불이 될 것이라는 것이었습니다. 하지만 그렇지 않습니다.

Alice 와 Bob 이 `require_recipient(chris)`를 호출하는 transfer 알림 핸들러를 가진 스마트 컨트랙트를 가지고 있다고 가정해 보겠습니다. Alice는 Bob에게 토큰을 보내고 Chris 는 유효한 토큰 컨트랙트와 함께 두 번의 transfer 통지를 받습니다. 하지만 그는 보내는 사람도 받는 사람도 아닙니다. Chris 의 컨트랙트에서 누가 to 인지 확인이 안 되면, 지불을 받는 것으로 받아들입니다. 카지노나 웹샵 같은 게임을 운영하면 진짜 돈로 취급하고 이를 진짜 가치를 되돌려 줍니다. 그리고 앨리스와 밥은 당신이 기진맥진할 때까지 토큰을 주고받을 수 있습니다. 이 문제는 특히 EOS 초기에 여러 번 발생했습니다. 따라서 알림 핸들러는 다음과 같아야 합니다.

따라서 통지 핸들러는 다음과 같이 작성되어야 합니다.

```
[[eosio::on_notify("*::transfer")]] 
  void on_payment (name from, name to, asset quantity, string memo) {
    if(to == _self) { 
      name tkcontract = get_first_receiver(); 
      // look up tkcontract in your list of accepted currencies 
      // verify the token symbol  
      // process the payment  
      }
  }
```

## 추측성 노드에서 테이블에 질의하지 말 것

이 공격은 2018년 말에 일어났고 EOS의 많은 카지노가 고갈되었습니다.&#x20;

`nodeos` 에는 `get_table_rows` 호출을 처리할 수 있는 몇 가지 옵션이 있습니다. 기본적으로 노드는, 전송이 진행 중이지만 아직 블록에 포함되지 않은 추측성 트랜잭션에 의해 변경될 수도 있는 테이블 행을 반환합니다.&#x20;

따라서 공격자는 어떤 카지노가 추측성 노드를 조회하고 있는지 찾아낸 뒤(혹은 그냥 시도해봤을 수도 있음), 블록에 포함되기 전에 실패하는 방식으로 베팅을 주입했습니다. 카지노에서는 추측성인 상태에서 베팅이 성공적으로 이루어졌다고 가정하고 실제 돈으로 상금을 돌려보냈습니다. 공격자는 심지어가 토큰을 전혀 사용하지 않았는데, 이는 특정한 짧은 시간이 지나면 실패하는 트랜잭션에 베팅하였기 때문입니다.

따라서 API 노드는 `read-mode=head` 를 사용하거나 들어오는 추측성 트랜잭션을 비활성화하도록 구성해야 합니다. 그리고 무엇보다 트랜잭션에 이러한 취약성이 있는 경우, dapp은 자체 통제 하에 있는 API 노드를 필요로 합니다. 또한 게임 컨트랙트는 보상을 지불하기 전에 베팅이 유효한지 다시 확인해야 합니다.

## 침입자가 인라인 액션을 주입할 것을 가정

이것이 [EOSX Vault](https://cmichel.io/eos-vault-sx-hack/)에서 일어난 일입니다. 컨트랙트는 특정 액션 및 알림 호출 순서를 가정했으며, 침입자는 알림에 반응하고 볼트 간에 인라인 작업을 주입하는 스마트 컨트랙트를 작성했습니다.&#x20;

따라서 경험상 컨트랙트가 정해진 순서대로 호출된다고 가정하지는 말아야 합니다. 그렇지 않은 경우 워크플로우 중간에 예상치 못한 호출이 발생하는 걸려오는 경우가 있습니다. 이를 염두에 두고 워크플로우를 구축하는 것이 좋습니다.

## 마이너스 자산

개발자들은 가끔 `asset` 타입이 음수를 허용한다는 것을 잊어버립니다. 스마트 컨트랙트에 일정량의 통화를 제출할 때 양수값임을 꼭 확인해야 합니다.

또한 부호 있는 64비트 `amount` 값이 오버플로우 될 수 있음도 명심해야 합니다. 공격자가 이를 악용할 수 있습니다.

## 기타 확인 사항

다음은 스마트 컨트랙트 설계시 일반적으로 미리 주의해야 할 사항입니다.

* 호출자를 인증
* 메모리 제어. 호출자의 풀에서 RAM을 할당하거나, 호출이 무언가를 지불하게 만드는 경우 RAM  풀에 대한 DOS 공격을 완화
* 가능한 모든 경우를 확인합니다. 컨트랙트는 완벽하게 작동하지 않을 수 있습니다. 컨트랙트 테이블에서 반환된 값이 틀림없다고 확신이 있더라도 항상 다시 확인하십시오. 예를 들면 다음과 같이 말입니다.

```
auto ciitr = ci.find(w.template_id);
check(ciitr != ci.end(), "Exception 3"); // this must never happen
```

* 항상 새로운 시선으로 코드를 보는 습관을 들이는 것이 좋습니다. 인간의 뇌는 너무 많은 것을 미리 지레 짐작하고 스스로 만들어낸 크고 작은 실수들을 보지 못합니다. 다른 사람이 확인하도록 하거나 적절한 보안 감사를 받는 것도 좋은 방법입니다. 테스트는 반드시 다른 사용자가 수행하도록 합니다.
