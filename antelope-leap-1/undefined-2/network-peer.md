# Network Peer 프로토콜(작업중)

## 개요

동작중인 Mandel 기반 블록체인 노드는 트랜잭션 릴레이, 블록 푸시 및 피어 간 상태 동기화를 위해 서로 통신할 수 있어야 합니다. 노드간 통신 용도로 사용되는 피어 투 피어(p2p) 프로토콜은, nodeos 서비스의 한 부분이며 모든 Mandel 노드에서 실행되고 있습니다.&#x20;

각 블록이 최종적으로 블록체인의 글로벌 상태(State) 내에서 최종성(Finality)에 도달하고, 각 노드에 마지막 비가역성 블록(LIB)을 계속 추가시킬 수 있도록 하려면 상태를 동기화하는 기능은 매우 중요합니다. 이러한 점에서, 블록을 동기화하고, 노드 간 트랜잭션을 전파하여 합의에 도달하고, 블록체인 상태를 진전시키는 것이 p2p 프로토콜의 가장 기본적인 목표입니다.

## 목표

정해진 생산 시간(0.5초) 안에 하나의 블록에 여러 트랜잭션을 삽입하는 작업을 처리하려면 p2p 프로토콜이 속도와 효율성을 염두에 두고 설계되어야 합니다. 즉, 효과적인 대역폭 내에서 트랜잭션 처리량을 극대화하고, 네트워크 및 운영 지연 시간을 모두 단축하는 두 가지 목표를 이루어 낼 수 있어야 합니다. 이를 달성하려면 다음과 같은 전략을 고려해야 합니다.

* 한 블록 내에 가능한 많은 트랜잭션을 적용하여 규모의 경제성을 극대화 한다.
* 블록 및 트랜잭션 사이에 중복된 정보를 최소화 한다.
* 노드 상태를 보다 효율적으로 브로드캐스트하고 동기화할 수 있다.
* 데이터 압축 및 바이너리 인코딩을 통해 페이로드 공간을 최소화 한다.

Mandel 소프트웨어 에서는 전체적으로 또는 부분적으로 이러한 전략의 대부분을 구현하고 있습니다. 예를 들어 데이터 압축은 선택 사항이지만 트랜잭션 수준에서 구현되어 있습니다. 또한 네트워크를 통해 오브젝트 인스턴스 및 프로토콜 메시지를 보낼 때 `net serializer` 가 바이너리 인코딩을 수행합니다.

## 아키텍쳐

p2p 프로토콜의 주요 목표는 노드를 안전하고 효율적으로 동기화하는 것입니다. 이 목표를 달성하기 위해 시스템은 기능을 다음과 같은 네 가지 주요 구성 요소에 위임하고 있습니다.

* Net Plugin : 블록을 동기화하고 피어 간 트랜잭션을 전달하기 위한 프로토콜을 정의한다
* Chain Controller : 노드 내에서 블록 및 수신된 트랜잭션을 처리/관리한다.
* Net Serializer: 네트워크 전송을 위해 메시지, 블록 및 트랜잭션을 직렬화한다.
* Local Chain: 가역성 블록까지 포함하는 블록체인의 로컬 복사본을 보관한다.

위 구성 요소 간의 관계는 아래 다이어그램에 설명되어 있습니다.

![](<../../.gitbook/assets/image (5).png>)

최상위 수준에는 노드와 다른 피어 간에 메시지를 교환하여 블록 및 트랜잭션을 동기화하는 `Net Plugin` 이 위치합니다. 일반적인 노드간의 메시지 흐름은 다음과 같습니다.

1. 노드 A는 `Net Plugin` 을 통해 노드 B 에게 메시지를 보낸다. (위 다이어그램 참조).
   1. 노드 A의 `Net Serializer` 가 메시지를 Packing 하여 노드 B로 보낸다.
   2. 노드 B의 `Net Serializer` 는 메시지를 압축 해제하고 자신의 `Net Plugin` 에 릴레이한다.
2. 메시지는 노드 B의 `Net Plugin` 에서 처리되어 적절한 액션을 발송한다.
3. 필요한 경우 `Net Plugin` 은 `Chain Controller` 를 통해 로컬 체인에 접근한 뒤 블록을 푸시 하거나 검색한다.

### 로컬 체인

로컬 체인은 블록체인의 온체인데이터의 로컬 복사본 입니다. 이는 노드에서 수신한 가역성 블록과 비가역성 블록으로 구성되며, 각 블록은 바로 앞의 블록과 암호화된 방식으로 연결됩니다. 비가역성 블록 목록은 블록체인의 변하지 않는(immutable) 복사본을 가지고 있습니다. 일반적으로 가역성 블록 목록은 길이가 훨씬 짧으며, 체인 컨트롤러가 새로운 블록을 푸시할 때, 포크 데이터베이스(Fork Database) 가 이 목록을 관리합니다.&#x20;

로컬 체인은 아래와 같이 나타낼 수 있습니다.

![](<../../.gitbook/assets/image (6) (1).png>)

각 노드는 블록 및 트랜잭션을 수신하고 다른 피어와 상태를 동기화하면서 블록체인의 로컬 복사본을 구성한다. 가역성 블록은 새롭게 수신된, 아직 최종 상태에 도달하지 않은 블록들 입니다. 따라서, 이러한 가역성 블록들은 LIB(Last Irreversible Block, 마지막 비가역성 블록)이라는 공통 선행 블럭 이후에 분기를 만들 가능성이 높습니다.&#x20;

LIB가 아닌, 일반적인 다른 가역성 블럭에도 뒤에 분기가 만들어질 수 있습니다. 사실, 분기된 모든 형제 브랜치는 항상 가장 가까운 곳에 공통된 선행 블록을 가지고 있습니다. 예를 들어 위의 다이어그램에서 블록 52b의 경우, LIB는 아니지만 블록 53a 및 53b 로 나누어진 분기에 대해 가장 가까운 공통 선행 블록이 됩니다. 로컬 체인에 존재하는 모든 브랜치는 전부는 아니지만 나중에 블록체인의 일부로 이어질 가능성을 가지고 있습니다.

#### LIB 블록

어떤 블록체인 노드 내부에 구성된 전체 비가역성 블록은, 다른 노드의 전체 비가역성 블록 (LIB 까지) 과 완전히 같아야 합니다. 이는 분산된 블록체인의 특징입니다. 최종적으로, LIB 블록을 따라가는 블록들이 마지막 위치까지 도달하게 되면 LIB 블록이 HB(헤드 블록)를 따라가면서 분기 중 하나를 통해 체인을 전진 시킵니다. LIB 블록이 전진하면서 비가역성 블록이 늘어난 블록체인이 성장하게 됩니다. 이 프로세스에서 헤드 블록은, 궁극적으로 어떤 브랜치를 선택할 지 결정하는데 사용되는 수신된 잠재적 헤드 블록 번호와 그 블록의 타임스탬프에 따라 체인의 분기를 여러 번 바꿀 수도 있습니다.

### 체인 컨트롤러(Chain Controller)

체인 컨트롤러는 트랜잭션 검증 및 실행, 블록 푸시 등, 로컬 체인 상태를 변경하는 블록과 트랜잭션에 관한 기본적인 작업들을 관리합니다. 체인 컨트롤러는 `Net Plugin` 으로부터 명령을 받으며, `Net Plugin` 에서 수신한 네트워크 메시지를 기반으로 블록 또는 트랜잭션에서 적절한 작업을 처리합니다. Mandel 노드 간에 블록 및 트랜잭션의 상태를 동기화하기 위해 서로 통신하는 동안 네트워크 메시지를 지속적으로 교환합니다.

#### 신호 생산자 및 소비자 (Signals' Producer and Consumer)

컨트롤러에 정의된 신호의 생산자 및 소비자, 그리고 정상적인 동작과, 포크와 재생 중에 신호의 수명 주기는 다음과 같습니다.

#### **pre\_accepted\_block (carry signed\_block\_ptr)**

* 생산자

| 모듈         | 함수                    | 조건                                                                                   |
| ---------- | --------------------- | ------------------------------------------------------------------------------------ |
| controller | push\_block           | fork db 에 블록이 추가되기 전.                                                                |
|            | replay\_push_\__block | fork db 에 재생된 블록이 추가되기 전(비가역성 블록은 재생되는 동안에는 fork db에 추가되지 않으므로 재생된 블록이 가역 상태일 때만 가능) |

* 소비자

| 모듈            | 사용법                                                     |
| ------------- | ------------------------------------------------------- |
| chain\_plugin | <p>체크포인트 검증<br>pre_accepted_block_channel 로 데이터를 포워</p> |

#### accepte\_block\_header **(carry block\_state\_ptr)**

[다음에 의하여 생산된다.](https://www.notion.so/344151686213477280ef8fa347b7bc79)

[다음에 의하여 소비된다.](https://www.notion.so/83c6d4f930c34bb4b8171866aa825a9d)

#### accepted\_block **(carry block\_state\_ptr)**

[다음에 의하여 생산된다.](https://www.notion.so/737d20108be942a5b0698e302dc3c304)

[다음에 의하여 소비된다.](https://www.notion.so/36906f850d324e7e98a68dd94db5fc71)

#### **irreversible\_block (carry block\_state\_ptr)**

[다음에 의하여 생산된다](https://www.notion.so/434af3c87380411e8d455990f61cfec0)

[다음에 의하여 소비된다](https://www.notion.so/98b2c87b9b52467cbdc5b13a525c2881)

#### **accepted\_transaction (carry transaction\_metadata\_ptr)**

[다음에 의하여 생산된다](https://www.notion.so/aa7c59c0ed1642da8044a631203d3b41)

[다음에 의하여 소비된다](https://www.notion.so/be0d13e9b0004fd78f225fa64b3ed0d7)

#### 이후는[https://developers.eos.io/welcome/latest/protocol/network\_peer\_protocol](https://developers.eos.io/welcome/latest/protocol/network\_peer\_protocol) 보고 작성

#### 신호의 수명 주기 (signal's lifecycle)

#### A. 정상적으로 블록 및 트랜잭션이 입력되는 작업

1.  트랜잭션이 블록체인에 푸시될 때 (RPC를 통하여, 또는 피어가 브로드캐스트한다)

    1-1. 트랜잭션이 성공적으로 실행되거나 유효성 검사에 실패한다. → accepted\_transaction이 컨트롤러에서 발신된다.

    1-2. transaction\_metadata를 accepted\_transaction\_channel로 전달하기 위한 신호에 chain\_plugin이 반응한다.

    1-3. mongodb\_plugin은 신호에 반응하여 나중에 처리할 transaction\_metadata 을 대기열에 추가한다.
2.  예약된 트랜잭션이 블록체인에 푸시될 때

    2-1. 트랜잭션이 성공적으로 실행됨/주관적으로 실패함(subjectively fail)/소프트 페일(Soft fail)/하드 페일(Hard fail) → accepted\_transaction이 컨트롤러에 의해 발생한다.

    2-2. chain\_plugin이 transaction\_metadata를 accepted\_transaction\_channel로 전달하기 위한 신호에 반응한다.

    2-3. mongodb\_plugin은 신호에 반응하여 나중에 처리할 transaction\_metadata을 대기열에 추가한다.
3.  블록이 블록체인에 푸시될 때 (RPC를 통해 또는 피어가 브로드캐스트한다)

    3-1. fork db에 블록을 추가하기 전

    → 컨트롤러에서 pre\_accepted\_block을 발생시킨다. 3-2. chain\_blocks는 블록 유효성 검사를 수행하여 block\_state를 accepted\_block\_header\_channel로 전달하고 체크포인트를 사용하여 유효성을 확인한다.

    3-3. 블록을 포크 db에 추가한 후 컨트롤러에서 accepted\_block\_header를 내보낸다.

    3-4. chain\_blocks는 신호에 반응하여 block\_state를 accepted\_block\_header\_channel로 전달한다.

    3-5. 그 다음 블록이 적용되며, 이때 블록 내부의 모든 트랜잭션과 예약된 트랜잭션이 푸시된다. push\_transaction 및 push\_scheduled\_transaction과 관련된 모든 신호가 방출됩니다(point A.1 및 A.2 참조).

    3-6. 블록을 커밋할 때 → accepted\_block이 컨트롤러에서 발생된다.

    3-7. net\_plugin이 신호에 반응하여 블록을 피어에 브로드캐스트한다.

    3-8. 새 블록이 비가역 상태가 되면 비가역 상태의 블록과 관련된 신호가 방출된다(A.5 지점 참조).
4.  블럭이 생성될 때

    4-1. 사용자가 블록을 생성하는 경우 블록이 커밋될 때 fork\_db에 추가된다. → accepted\_block\_header가 컨트롤러에서 발생한다.

    4-2. chain\_plugin은 block\_state를 accepted\_block\_header\_channel로 포워드하는 신호에 반응하고 체크포인트를 사용하여 유효성을 검사한다.

    4-3. 그 직후(블록을 커밋하는 동안) → accepted\_block이 컨트롤러에 의해 발생한다.

    4-4. net\_plugin이 신호에 반응하여 블록을 피어에 브로드캐스트한다.

    4-5. 새 블록이 비가역 상태가 되면 비가역 상태의 블록과 관련된 신호가 방출된다(A.5 지점 참조).
5.  블록이 비가역 상태가 될 때

    5-1. 블록이 비가역 상태가 된 것으로 간주되면, 블록이 블록 로그에 추가되고 체인베이스 db가 커밋되기 전에 컨트롤러에서 irreversible\_block 을 발생시킨다.

    5-2. chain\_plugin은 block\_state를 irreversible\_block\_channel로 포워드 하는 신호에 반응하며 wasm\_interface 의 LIB도 설정한다.

    5-3. mongodb\_plugin은 신호에 반응하여 나중에 처리할 transaction\_metadata를 대기열에 추가한다.

#### B. Fork가 나타나고(presented)되고 해결(resolved)되는 작업

1. 포크가 나타나면 블록체인은 기존의 모든 블록을 포킹 포인트까지 팝업한 다음, 포크의 새로운 모든 블록을 적용한다.
2. 새 블록을 적용하면 블록 내부의 모든 트랜잭션과 예약된 트랜잭션이 푸시된다. push\_transaction 및 push\_scheduled\_transaction과 관련된 모든 신호가 방출된다 (A.1 및 A.2 참조).
3. 그런 다음 새 블록을 커밋할 때 accepted\_block이 컨트롤러에 의해 발생한다.
4. net\_plugin 이 신호에 반응하여 블록을 피어에 브로드캐스트한다.
5. 새 블록이 비가역 상태가 되면 비가역 블록과 관련된 신호가 방출된다 (A.5 지점 참조).

#### C. 일반 재생(재생 최적화 적용 또는 미적용)

1. 비가역 블록을 재생할 때 irreversible\_block이 컨트롤러에서 발생한다.
2. A.5를 참조하여 irreversible\_block 신호가 어떻게 응답하는지 확인한다.
3. 가역 블록을 재생할 때 블록이 fork\_db 에 추가되기 전에 pre\_accepted\_block가 컨트롤러에서 발생한다.
4. 가역 블록을 재생할 때 블록이 fork\_db 에 추가된 후에 accepted\_block\_header가 컨트롤러에서 발생한다.
5. 가역 블록을 재생할 때 블록이 커밋되면 accepted\_block이 컨트롤러에서 발생한다.
6. pre\_accepted\_block, accepted\_block, accepted\_block\_header 및 accepted\_block 신호가 어떻게 응답하는지 보려면 A.3을 참조한다.

#### 포크 데이터베이스

포크 데이터베이스(Fork DB)는 체인 컨트롤러가 노드의 로컬 체인에서 작업을 수행할 수 있도록 내부 인터페이스를 제공합니다. 다른 피어 노드로부터 새로운 블록을 받아오면 체인 컨트롤러는 먼저 이 블록을 포크 DB로 푸시합니다. 그런 다음 각 블록은 이전 블록과 암호화된 방식으로 연결됩니다. 이전 블록이 한 개 이상 있을 수 있기 때문에 이 과정에서 미니포크(mini-forks)라는 일시적인 브랜치가 나올 가능성이 있습니다. 따라서 포크 DB는 다음과 같은 세 가지 기능을 제공합니다.

* 푸시된 블록(새 헤드 블록)이 어느 분기부터 빌드오프되는지 결정한다.
* 헤드 블록, 루트 블록 및 LIB 블록을 전진시킨다.
* 유효하지 않은 분기를 잘라내고 떨어져나간 블록(orphaned blocks)을 제거한다.

포크 DB는 본질적으로 블록체인을 계속 성장시키는, 실제로 브랜치가 될 수 있는 노드 내에 모든 후보 블록 브랜치를 포함하고 있습니다. 루트 블록은 항상 가역 블록 트리가 시작되는 블록을 표시하며, LIB가 진전되는 경우를 제외하면(이 경우 루트 블록이 따라잡아야 한다) LIB 블록과 일치하게 됩니다. 포크 DB 내의 새로운 블록을 통해 전진하는 LIB 블록의 계산은 궁극적으로 어떤 분기가 선택되는지를 결정할 것입니다. LIB 블록이 진행됨에 따라 루트 블록은 새로운 LIB를 따라잡으며, LIB 뒤에 선행 노드가 있는 모든 후보 분기가 제거됩니다. 이는 아래 그림에 잘 설명되어 있습니다.

![](<../../.gitbook/assets/image (10).png>)

위의 다이어그램을 보면 LIB가 블록 51에서 블록 52c, 블록 53c로 전진한 후 블록 52b에서 시작하는 분기가 제거되는 것을 볼 수 있습니다. 따라서 52b, 53a, 53b는 유효하지 않은 블록이 됩니다. 블록체인이 성장하면서 가역 블록을 따라 LIB가 이동하고, LIB가 거쳐간 이전의 블록들은 변하지 않는 블록체인의 일부로 확정 되어 포크 DB로 부터 로컬 체인으로 이동하게 됩니다. 마지막으로, 54d 블록으로 부터은 새로운 블록이 빌드될 수 있기 때문에 54d 블록은 포크 DB에 보관됩니다.

### Net Plugin

Net Plugin은 Mandel 노드 사이의 p2p 통신 메시지를 정의합니다. Net Plugin 의 주요 목적은 요청이 있을 때 유효한 블록을 동기화하고, 유효한 트랜잭션을 전달하는 것입니다. 이를 위해 Net Plugin 은 구성 요소들에게 기능을 위임하고 있습니다.

* Sync Manager: 다른 피어 노드들과 노드의 블록 동기화 상태를 유지.
* 디스패치 관리자: 노드에서 보낸 블록 및 트랜잭션 목록을 유지 관리.
* 연결 목록: 이 노드가 현재 연결되어 있는 활성 피어 목록.
* 메시지 핸들러: 해당 핸들러로 프로토콜 메시지를 발송. (4.2 [프로토콜 메시지](https://developers.eos.io/welcome/latest/protocol/network\_peer\_protocol/#42-protocol-messages) 참조).

#### Sync Manager

Sync Manager는 노드가 다른 피어 노드와 블록 상태를 동기화하기 위한 기능을 가지고 있습니다. Sync Manager 는 다른 피어가 보낸 메시지를 처리하고, 어떤 피어 노드의 LIB 또는 헤드 블록의 상태에 기초하여 블록 동기화를 수행합니다. 어떤 노드는 동기화 타이밍에 따라 다음과 같은 상태를 가집니다.

* LIB Catch-Up: 노드가 다른 피어 노드의 LIB 블록과 동기화하려고 함
* Head Catch-Up: 노드가 다른 피어 노드의 헤드 블록과 동기화하려고 함.
* In-Sync: LIB 및 헤드 블록이 모두 다른 피어 노드와 동기화됨.

노드의 LIB 나 헤드 블록이 다른 피어 노드보다 뒤쳐져 있는 경우, 노드는 누락된 블록을 검색하기 위해 연결된 피어에게동기화 요청 메시지를 만들어 전달합니다. 마찬가지로 연결된 다른 피어 노드느의 LIB 또는 헤드 블록이 뒤쳐져 있을 경우,그  노드는 동기화해야 할 블록을 이 노드에 알리기 위해 메시지를 보낼 것입니다. 동기화 모드에 대한 자세한 내용은 [3.작동 모드](https://developers.eos.io/welcome/latest/protocol/network\_peer\_protocol/#3-operation-modes)를 참조하십시오.

#### 디스패치 매니저

디스패치 매니저는 노드가 받은 블록 상태와 느슨한 트랜잭션(Loose Transaction)을 관리합니다. 상태는 블록이나 트랜잭션을 식별하기 위한 기본 정보를 포함하고 있으며, 블록 상태와 트랜잭션 상태의 두 가지 인덱스 목록 내에서 관리됩니다.

* 블록 상태 목록(Block State List): 수신된 모든 블록에 대해 노드별로 관리되는 블록 상태 목록.
* 트랜잭션 상태 목록(Transaction State List)): 수신된 모든 트랜잭션에 대해 노드별로 관리되는 트랜잭션 상태 목록.

이들을 사용하여 어떤 피어 노드가 필요한 블록이나 트랜잭션을 가지고 있는지 빠르게 찾을 수 있습니다.

#### 블록 상태(Block State)

블록 상태는 어떤 블록과 그 블록을 보낸 피어 노드를 식별합니다. 그러나 본질적으로는 일시적인 것이기 때문에 노드가 활성화되어 있을 때만 유효합니다. 블록 상태에는 다음 필드가 포함된다.

[블록상태](https://www.notion.so/d1d06c9d1f9b4d6d96388c8f7655cdb9)

블록 상태 목록은 더 빠른 조회를 위해 블록 ID, 블록 번호 및 연결 ID로 인덱스를 생성한다. 이렇게 하면 하나 이상의 인덱스된 속성이 주어진 블록에 대해 목록을 쿼리할 수 있다.

#### 트랜잭션 상태(Transaction State)

거래 상태는 느슨한 거래와 그 거래가 전달되어 온 피어를 식별한다. 또한 본질적으로 일시적이기 때문에 노드가 활성화되어 있을 때만 유효하다. 트랜잭션 상태에는 다음 필드가 포함된다.

[트랜잭션 상태](https://www.notion.so/004e6e37d00a4b0894d88f7b2d919829)

block\_num은 트랜잭션이 수신될 때 노드의 헤드 블록 번호를 저장한다. 유효기간과 관계없이 LIB 블록 번호가 헤드 블록 번호를 따라잡았을 때 트랜잭션을 삭제하는 백업 메커니즘으로 사용된다.

트랜잭션 상태 목록은 빠른 조회를 위해 트랜잭션 ID, 만료 시간, 블록 번호 및 연결 ID를 사용하여 인덱스를 생성한다. 이렇게 하면 하나 이상의 인덱스된 속성이 지정된 트랜잭션에 대해 목록을 쿼리할 수 있다.

#### 상태 재활용(State Recycling)

LIB 블록이 진전됨에 따라(3.3.1. [LIB 캐치업 모드](https://developers.eos.io/welcome/latest/protocol/network\_peer\_protocol/#331-lib-catch-up-mode) 참조) 새로운 LIB 블록 이전의 모든 블록은 최종으로 간주되므로, 노드가 유지 관리하는 연결 목록에서 각 피어가 소유한 블록 상태 목록을 포함하여 블록 상태의 로컬 목록에서 해당 상태가 제거된다. 마찬가지로, 트랜잭션 상태는 만료 시간을 기준으로 트랜잭션 목록에서 제거된다. 따라서 거래가 만료된 후에는 거래 상태가 모든 거래 상태 목록에서 제거된다.

블록 상태와 트랜잭션 상태의 목록은 발자국이 경미(light footprint)하고 회전성이 높기(High rotation) 때문에 보다 빠른 접근을 위해 메모리 안에서 관리된다. 노드에서 수신한 블록의 실제 내용과 트랜잭션은 각각 포크 데이터베이스에 임시로 저장되며, 적용 및 미적용 트랜잭션의 다양한 수신 대기열에 저장된다.

#### 연결 목록(Connection List)

연결 목록에는 각 피어의 연결 상태가 포함되어 있다. 그것은 p2p 프로토콜 버전, 노드가 알고 있는 피어로부터 수신된 블록 및 트랜잭션의 상태, 그것이 현재 그 피어와 동기화되고 있는지 여부, 마지막으로 주고받은 핸드셰이크 메시지, 피어가 노드로부터 정보를 요청했는지 여부, 소켓 상태, 노드 ID 등에 관한 정보를 보관한다. 연결 상태에는 다음과 같은 관련 필드가 포함된다.

* 요청한 정보: 피어가 노드에 정보를 요청했는지 여부.
* 소켓 상태: TCP 연결 상태를 유지하는 소켓 구조에 대한 포인터.
* 노드 ID: 피어의 노드와 다른 피어를 구분하는 실제 노드 ID.
* 마지막 핸드셰이크 수신: 피어에서 받은 마지막 핸드셰이크 메시지 인스턴스.
* 마지막 핸드셰이크 전송: 피어로 전송된 마지막 핸드셰이크 메시지 인스턴스.
* 핸드셰이크 전송 횟수: 피어에 보낸 핸드셰이크 메시지 수입니다.
* 동기화: 노드가 피어와 동기화되는지 여부
* 프로토콜 버전: 피어의 Net Plugin에 의해 구현된 내부 프로토콜 버전.

블록 상태는 다음 필드로 구성된다.

* 블록 ID: 블록의 일련화된 콘텐츠의 해시.
* 블록 번호: 생성 이후 실제 블록 번호.

트랜잭션 상태는 다음 필드로 구성된다.

* 트랜잭션 ID: 트랜잭션의 일련화된 내용에 대한 해시.
* 블록 번호: 거래가 포함된 실제 블록 번호.
* 만료 시간: 트랜잭션이 만료되는 시간(초)

### Net Serializer

Net Serializer 는 다음과 같은 두 가지 주요 역할을 수행합니다.

* 네트워크를 통해 전송해야 하는 오브젝트와 메시지를 직렬화.
* 암호화 해시 되어야 하는 오브젝트와 메시지를 직렬화.

첫 번째 경우, 직렬화된 각 오브젝트나 메시지는 이를 수신하는 다른 쪽 끝에서 네트워크로부터 수신하는 즉시 역직렬화 한 뒤 다음 작업을 진행 해야 합니다. 후자의 경우, 해당 컨텐츠 대한 암호 해시를 생성하려면 오브젝트 인스턴스 내의 특정 필드를 직렬화 해야 합니다. 어떠한 오브젝트 타입(액션, 트랜잭션, 블록 등)의 ID는 대부분 오브젝트 인스턴스가 가지고 있는 필드를 암호화 해싱하여 만들어집니다.

## 운영 모드(Operation Mode)

노드를 운영하면 이 노드가 연결된 다른 피어 노드에 대하여 다음과 같은 세 가지 상태 중 하나를 가질 수 있습니다.

* In-Sync 모드: 이 노드가 피어 노드와 동기화된 상태이므로 해당 피어에서 블록이 필요하지 않음.
* LIB Catch-Up 모드: 이 노드의 LIB 블록이 상대 피어 노드의 LIB 보다 뒤져 있기 때문에 블록을 받아와야 한다.
* HEAD Catch-Up 모드: 이 노드의 HEAD 블록이 피어 노드의 HEAD 보다 뒤쳐져 있기 때문에 블록을 받아와야 한다.

각 노드의 운영 모드(Operation Mode)는 nodeos 서비스의 Net Plugin 안에 있는 sync Manager 컨텍스트에 저장됩니다. 따라서 노드는 연결된 피어 노드에 대해 항상 동기화 모드 또는 캐치업 모드에 있게 됩니다다. 이를 통해 LIB 및 헤드 블록이 업데이트되고 다른 피어 노드로부터 새로운 새 블록이 수신됨에 따라 노드가 Catch-up 상태와 in-sync 상태 사이를 왔다 갔다 할 수 있습니다.

### 블록 ID

Mandel 소프트웨어는 블록 ID를 비교하여 두 블록이 일치하는지, 동일한 콘텐츠를 보유하는지를 확인합니다. 블록 ID는 어떤 블록 헤더와 블록 번호를 가지는가에 따라 달라집니다.([Consensus Protocol: 5.1. Block Structure](https://developers.eos.io/welcome/latest/protocol/consensus\_protocol#51-block-structure) 참조).&#x20;

두 블록이 동일한지 확인하는 것은 어떤 노드의 로컬 체인과 피어 노드의 로컬 체인을 동기화하는 데 매우 중요합니다. 블록 컨텐츠로부터 블록 ID를 생성하기 위해 블록 헤더를 직렬화하고 SHA-256 해시 다이제스트를 생성합니다. 가장 중요한 32비트는 블록 번호로 할당되고 덜 중요한 해시의 나머지 224비트는 유지됩니다.&#x20;

블록 헤더에는 트랜잭션 merkle tree 뿐만 아니라와 액션 merkle tree 의 루트 해시도 모두 포함되어 있습니다. 따라서 블록 ID는 블록에 포함된 전체 트랜잭션뿐만 아니라 각 트랜잭션에 포함된 전체 액션에 따라 달라지게 됩니다.

### 동기화(in-sync) 모드

in-sync 모드에서는 이 노드의 헤드 블록이 피어 노드의 헤드 블록을 따라잡은 상태가 되는데, 이는 이 노드의 블록이 동기화되어 있음을 의미합니다. 노드가 in-sync 모드일 경우 피어 노드로 부터 추가 블록을 요청하지 않고 다음과 같은 작업을 수행합니다.

* 트랜잭션 검증. 트랜잭션이 유효하지 않으면 삭제하고 유효하면 다른 피어 노드에 전달.
* 블록 유효성 검사. 블록이 유효하지 않은 경우 삭제하고 유효하면 요청이 있을 시 다른 피어 노드로 전달.

따라서 이 모드는 지연 시간에 유리하도록 대역폭을 거래하며, 처리 오버헤드가 낮아져 TaPoS(지분 증명으로서의 트랜잭션)에 의존하는 트랜잭션을 검증하는 데 특히 유용합니다.

느슨한 트랜잭션의 경우 아직 유효하고 만료되지 않은 상태라면 항상 상대에게 전달됩니다. 반면에 블록은 피어가 명시적으로 요청하는 경우에만 전달됩니다. 이 덕분에 네트워크 오버헤드를 줄일 수 있습니다.

### 따라잡기(Catch-up) 모드

어떤 노드의 헤드 블록이 피어 노드의 LIB 또는 헤드 블록보다 뒤쳐져 있을 때 Catch-up 모드가 됩니다. 동기화 다음 두 가지 순서대로 수행됩니다.

1. 두 노드가 가진, 가장 가깝게 있는 공통된 이전 블록(nearest common ancestor) + 1 블록으로부터 상대 피어 노드의 LIB 까지 이 노드의 LIB를 동기화
2. 두 노드가 가진, 가장 가깝게 있는 공통된 이전 블록(nearest common ancestor) + 1 블록에서 상대 피어 노드의 HEAD까지 이 노드의 HEAD를 동기화

즉 노드의 LIB 블록이 먼저 업데이트 된 다음, 헤드 블록이 업데이트 됩니다.

#### **LIB Catch-Up 모드**

노드의 LIB 블록이 피어 노드의 LIB 블록을 따라잡아야 하는 위의 사례 1의 경우, 동기화 전후의 상황을 아래 다이어그램에서 설명하고 있습니다. 명확한 설명을 위해 적용 불가능한 분기는 다이어그램에 표시하지 않았습니다.

![](<../../.gitbook/assets/image (7).png>)

위의 다이어그램에서, 노드의 로컬 체인은 완성된 블록 91과 92(피어 노드의 LIB)를 자신의 LIB(블록 90) 뒤에 추가하여 피어 노드의 로컬 체인과 동기화 합니다. 유의할 점은, 이렇게 하면 로컬 노드에서 블록 91n, 92n, 93n 으로 이어진 임시 포크가 삭제된다는 점 입니다.&#x20;

또한 이 노드에는 완료되지 않았음을 나타내는 "n" 접미사(노드의 줄임말)가 있어 피어의 블록과는 다를 수 있다는 점에도 유의합니다. 이는 상대 피어의 완료되지 않은(unfinalised) 블록에도 동일하게 적용되며, 이러한 블록들은 접미사 "p"(피어의 줄임말)를 가집니다. 노드가 동기화 된 후에는, LIB(lib)와 헤드 블록(hb) 모두 같은 블록 번호를 가리키게 됩니다.

#### 3.3.2. HEAD Catch-up 모드

로컬 노드의 LIB 블록이 피어 노드의 LIB와 동기화되고 난 다음, 어느쪽이든 체인에 새로운 블록이 푸시될 것입니다. 위의 사례 2는 피어 노드의 체인이 로컬 노드의 체인보다 긴 경우를 다루고 있습니다. 이는 다음 다이어그램에서 동기화 전후에 로컬 노드와 피어 노드가 가진의 로컬 체인을 보여주고 있습니다.

![](<../../.gitbook/assets/image (4).png>)

위의 사례 1 또는 2에서 볼 수 있듯,  로컬 노드의 헤드 블록에서 시작하여 체인을 뒤로 거슬러 올러가 LIB 블록에서 끝나는, 첫 번째 공통 조상 블록(이 블록은 현재 동기화된 상태)을 찾는 작업이 로컬 노드의 동기화 프로세스에 포함됩니다. (3.3.1. LIB 캐치업 모드 참조). 최악의 경우, 동기화된 LIB가 가장 가까운 공통 조상입니다. 위의 다이어그램에서, 로컬 노드의 체인은 헤드 블록 94n, 93n 등으로부터 거슬러 올라기가 시작하며, 피어 체인의 블록 94p, 93p 등을 일치시키려고 합니다. 일치하는 첫 번째 블록은 가장 가까운 공통 조상(다이어그램에서 블록 93n과 93p)입니다. 따라서 93p 뒤의 블록 94p와 95p가 검색되어, 가장 가까운 공통 조상(93n) 직후에 노드의 체인에 추가되며, 다시 93n,p라는 라벨을 붙입니다(3.3.3 참조). 블록 검색 프로세스). 마지막으로 블록 95p는 로컬 노드의 헤드 블록이 되고, 이 시점이 되면 로컬 노드는 피어 노드와 완전히 동기화되기 때문에 in-sync 모드로 전환됩니다.

#### 블록 검색(Block Retrieval)

공통 조상을 찾은 다음, 로컬 노드에 필요한 블록(가장 가까운 공통 조상의 다음 블록부터 피어 노드의 헤드 블록 사이의 블록들)을 검색하기 위해 동기화 요청 메시지가 전송됩니다.

대역폭을 효과적으로 활용하기 위해, 필요한 경우 하나의 피어 노드 뿐만이 아니라 여러 피어 노드에게서 필요한 블록을 얻어 옵니다. 필요한 블록 수에 따라 지정된 피어 노드에서 다운로드할 시작 블록 번호와 끝 블록 번호를 지정하여 블록을 한 덩어리로(Chunk)로 요청합니다. 로컬 노드는 블록 상태 목록을 사용하여 각 피어가 가지고 있는 블록을 추적하므로 이 정보는 블록 청크를 요청할 연결된 피어 노드를 결정하는 데 사용됩니다. 이 프로세스는 아래 다이어그램에 설명되어 있습니다.

![](<../../.gitbook/assets/image (6).png>)

피어 노드의 LIB와 헤드 블록을 모두 따라잡으면, Sync Manager의 운영모드는 Catch-up 모드에서 in-sync 모드로 전환됩니다.

#### 3.4. 모드 전환

최종적으로 어떤 노드와 그 피어 노드 모두 다른 피어 노드로부터 새로운 블록을 받고, 블록을 각각의 로컬 체인에 삽입합니다. 이로 인해 각 체인의 헤드 블록이 전진하게 됩니다. 어떤 체인이 먼저 성장하느냐에 따라 다음 중 하나가 발생합니다.

* 노드는 헤드 블록 정보와 함께 피어 노드에 따라잡기 요청 메시지(Catch-up request message)를 전송.
* 노드는 동기화할 필요가 있는 피어 노드에게 알리기 위해 따라잡기 알림 메시지(Catch-up notice message)를 전송.

첫 번째 경우, 노드가 동기화 모드에서 헤드 캐치업 모드로 전환됩니다. 두 번째 경우, 피어 노드는 노드로부터 알림 메시지를 받은 후 헤드 캐치업 모드로 전환됩니다. 실제로 동기화 모드는 지속 시간이 길지 않습니다. 바쁘게 움직이는 Antelope 블록체인의 경우 노드는 대부분의 시간을 캐치업 모드에서 트랜잭션 검증과 캐치업 메시지가 수신된 후 체인을 동기화하는데 사용합니다.

## 프로토콜 알고리즘

p2p 프로토콜 알고리즘은 모든 노드에서 실행되며, 검증된 트랜잭션과 검증된 블록을 포워딩합니다. 구 EOSIO v2.0을 시작하면 노드는 수신한 검증되지 않은 블록의 블록 ID도 전달합니다. 일반적으로 과정을 단순화하면 다음과 같다.

1. 노드는 피어 노드에게 데이터를 요청하거나 제어 메시지를 전송한다.
2. 피어 노드가 요청을 수행할 수 있다면 그 요청을 실행한다. 다시 1을 반복한다.

데이터 메시지에는 블록 콘텐츠 또는 트랜잭션 콘텐츠가 포함되어 있습니다. 제어 메시지는 노드와 그 피어 노드사이의 블록 및 트랜잭션의 동기화를 가능하게 합니다([프로토콜 메시지](https://developers.eos.io/welcome/latest/protocol/network\_peer\_protocol/#42-protocol-messages) 참조). 이렇게 동기화 되려면 각 노드는 자신의 블록 및 트랜잭션 상태뿐만 아니라 피어 노드 상태 정보도 검색할 수 있어야 합니다.

### 4.1. Node/Peers 상태

상태를 동기화하기 전에 각 노드는 자신이 가진 블록 및 트랜잭션의 현재 상태를 알아야 합니다. 또한 동일한 정보를 얻기 위해 다른 피어 노드에 질의 할 수 있어야 합니다. 특히 노드는 필요할 때 다음 정보를 얻을 수 있어야 합니다.

* 각 노드가 현재 보유하고 있는 블록과 트랜잭션을 알아낼 수 있다.
* 모든 노드는 자신의 피어 노드가 어떤 블록과 트랜잭션을 가지고 있는지 알아낼 수 있다.
* 각 노드는 자신이 요청한 블록과 트랜잭션을 파악할 수 있다.
* 모든 노드는 각 노드가 지정된 트랜잭션을 수신한 시기를 파악할 수 있다.

위와 같은 질의를 수행하고 상태를 동기화하기 위해, Net Plugin은 노드 간에 교환하는 특정 통신 메시지를 정의합니다. 이러한 메시지는 Net Plugin 이 전송하며 TCP 연결을 통해 수신됩니다.&#x20;

### 4.2 프로토콜 메시지

p2p 프로토콜은 노드간 p2p 커뮤니케이션을 위해 다음과 같은 컨트롤 메시지를 정의합니다.

[Untitled](https://www.notion.so/08d8ac0b65c345f1ab69d55ed1fa785f)

프로토콜은 또한 p2p 네트워크의 피어들 사이에서 블록의 실제 내용이나 느슨한 거래(Loose transaction)를 교환하기 위해 다음과 같은 데이터 메시지를 정의하고 있습니다.

[Untitled](https://www.notion.so/653dc80b6cb54d97805e63875fd1fe7b)

#### 4.2.1 **Handshake Message**

핸드셰이크 메시지는 어떤 노드가 다른 피어 노드에 연결할 때 전송하며, 연결하는 노드가 피어 노드에게 체인 상태(LIB number/ID 및 Head block number/ID)를 전달하기 위해 사용합니다. 또한 처음 연결할 때 노드에 대한 기본적인 유효성 검사(피어 노드가 동일한 블록체인에 속하는지 여부, 필드가 범위 내에 있는지 검증, 노드에서 일관되지 않은 블록 상태를 감지(ex: LIB가 헤드 블록보다 앞서 있는 상태 등등 )를 수행하는 데도 사용됩니다.&#x20;

핸드셰이크 메시지는 다음 필드로 구성됩니다.

[Untitled](https://www.notion.so/23c18937b4f540f4a6362977d4a27bd3)

모든 검사가 성공하면 피어 노드는 계속해서 nodeos 시작 시 해당 피어의 net plugin 대해 지정된 `--allowed-connection` 설정에 기반하여 연결된 노드를 인증하는 작업을 수행합니다.

* Any: 인증 없이 연결이 허용됨.
* Producer: p2p 프로토콜을 통해 피어 키를 얻음.
* Specified: 설정을 통해 피어 키가 제공됨.
* None: 노드에서 연결 요청을 허용하지 않음.

피어 키는 피어 노드에 연결을 시도하는 노드의 공개 키를 의미합니다. 인증에 성공하면 수신 노드는 핸드셰이크 메시지를 다시 전송하여 연결 노드를 인식하는데, 연결 노드는 이 메시지를 위에서와 동일한 방식으로 검증합니다. 마지막으로, 수신 노드는 피어의 헤드 블록 또는 자신의 헤드 블록이 동기화가 필요한지 점검합니다. 이것은 자신의 헤드 블록과 관련하여 헤드 블록의 상태와 연결 노드의 LIB를 확인함으로써 이루어집니다. 이렇게 점검하면서, 수신 노드는 어떤 체인이 동기화가 필요한지 결정합니다.

#### 체인 크기 메시지(Chain Size Message)

체인 크기 메시지는 나중에 사용하기 위해 정의되었기 때문에 현재는 구현되어 있지 않습니다. 당초 아이디어는 다른 피어 노드에 성공적으로 연결한 후 노드의 체인 상태에 대한 임시 상태 통지를 전송하는 것이었습니다.&#x20;

체인 크기 메시지는 다음 필드로 구성됩니다.

[Untitled](https://www.notion.so/b83bb27a60744c53a9ddf6551f36244d)

체인 크기 메시지 대신는 핸드셰이크 메시지를 사용할 수 있습니다. 핸드셰이크 메시지도 LIB와 헤드 블록의 상태를 보내긴 하지만 추가 정보가 더 포함되어 있기 때문에 주로 이쪽을 더 사용합니다.

#### Go Away 메시지

Go Away 메시지는 연결을 닫기 전에 피어 노드로 전송됩니다. 이 메시지는 대개 노드가 p2p 프로토콜로 더 이상 계속  연결 할 수 없도록 방지하기 위한 오류 때문에 발생합니다.&#x20;

Go Away 메시지는 다음 필드로 구성됩니다.

[Untitled](https://www.notion.so/8b24b40b529e4144b6f1f634fd566ff5)

연결 중단 이유 오류 코드는 다음과 같습니다.

* No reason: 오류 없음. 기본값.
* Self: 노드가 자기 스스로에게 연결을 시도하고 있음.
* Duplicate: 피어 노드에서 중복 연결이 감지됨
* Wrong Chain: 피어 노드의 체인 ID가 일치하지 않음.
* Wrong Version: 피어 노드의 네트워크 버전이 일치하지 않음.
* Forked: 피어 노드의 비가역성 블록이 다름
* Unlinkable: 피어 노드가 사용할 수 없는 블록을 전송함
* Bad transaction: 피어 노드가 확인에 실패한 트랜잭션을 전송함.
* Validation: 피어 노드가 유효성 검사에 실패한 블록을 전송함.
* Benign other: 타임아웃등의 이유. 치명적인 것은 아니지만 리셋을 보증한다.
* Fatal other: 아직 격리(isolated)되지 않은 치명적인 오류를 모두 포착.
* Authentication: 피어 노드 인증 실패.

피어 노드가 Go Away 메시지를 수신한 후 피어 노드도 연결을 닫아야 합니다.

#### Time 메시지

Time 메시지는 피어 노드간의 이벤트를 동기화하고, 시간 간격을 측정하며, 중복 메시지, 잘못된 타임스탬프, 손상된 노드 등과 같은 네트워크 이상을 탐지하는 데 사용됩니다. 시간 메시지는 다음 필드로 구성됩니다.

[Untitled](https://www.notion.so/2c56c1fd66e946549f925a3b71bb3d3b)

#### Notice 메시지

노드가 현재 어떤 블록과 느슨한 트랜잭션을 가지고 있는지 피어 노드에게 알리기 위해 알림 메시지를 전송합니다. Notice 메시지는 다음 필드로 구성됩니다.

[Untitled](https://www.notion.so/fe848ae6045043bab62e3c3f7fa8cb12)

알림 메시지는 실제 블록이나 트랜잭션이 아닌 블록 ID와 트랜잭션 ID만 포함하기 때문에 가볍습니다.

#### Request 메시지

Request 메시지는 현재 노드가 필요로 하는 블록과 느슨한 트랜잭션을 피어 노드에게 알리기 위해 전송됩니다. Request 메시지는 다음 필드로 구성됩니다.

[Untitled](https://www.notion.so/61a14b542adc4457b4037b6211cc6df8)

#### Sync Request 메시지

Sync Request 메시지는 피어 노드로부터 다양한 블록을 요청한다. Sync Request 메시지는 다음 필드로 구성됩니다.

[Untitled](https://www.notion.so/2e42ff7e1ba049868e2b1720f0af4bac)

Sync Request 메시지를 수신하면 피어 노는 지정된 블록 번호 범위에 해당하는 블록을 반환합니다.

### 4.3. 메시지 핸들러

p2p 프로토콜은 이벤트 기반 모델을 사용하여 메시지를 처리하므로, 메시지를 수신할 때 폴링(polling)이나 루핑(looping)은 사용하지 않습니다. 내부적으로는 각 메시지가 대기열에 배치되고 다음 메시지가 줄지어 해당 메시지 핸들러로 발송되어 처리됩니다. 높은 수준에서 메시지 핸들러는 다음과 같이 정의할 수 있습니다.

```
receiver/read handler:
      if handshake message:
         verify that peer's network protocol is valid
         if node's LIB < peer's LIB:
            sync LIB with peer's; continue
         if node's LIB > peer's LIB:
            send LIB catchup notice message; continue
      if notice message:
         update list of blocks/transactions known by remote peer
      if trx message:
         insert into global state as unvalidated
         validate transaction; drop if invalid, forward if valid
      else
         close the connection
```

### 4.4 발송 대기열 (**Send Queue)**

프로토콜 메시지는 버퍼 대기열에 배치된 후 연결된 알맞는 피어 노드로 전송됩니다. 더 높은 수준에서 노드는 라운드 로빈 방식으로 연결된 각 피어 노드와 함께 다음과 같은 작업을 수행합니다.

```
send/write loop:
      if peer knows the LIB:
         if peer does not know we have a block or transaction:
            next iteration
         if peer does not know about a block:
            send transactions for block that peer does not know
            next iteration 
         if peer does not know about transactions:
            sends oldest transactions unknown to remote peer
            next iteration
         wait for new validated block, transaction, or peer signal
      else:
         assume peer is in catchup mode (operating on request/response)
         wait for notice of sync from the read loop
```

## 5. 프로토콜 개선

p2p 프로토콜과 관련된 모든 소프트웨어 업데이트는 모든 노드에서 점진적이고 일관성 있게 확장되어야 합니다. 이는 가능한 경우 역호환성 방식으로 새로운 기능을 배치하면서 운영 다운타임을 줄이고 잠재적으로 는 다운타임을 최소화하는 업데이트를 설치하는 것이라 설명할 수 있습니다. 한편, 프로토콜 메시지의 데이터 압축과 바이너리 인코딩을 사용하는 등 메시지 공간을 최소화하는 조치를 취함으로써 데이터 처리량을 높일 수 있습니다.
